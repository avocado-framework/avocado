Debugging with GDB
==================

Avocado has two levels of GDB support, one by using the Avocado GDB APIs
to fire up GDB and interact with it, and other by transparently debugging
binaries inside the GNU Debugger based on command line only options. This
later option means that any test that uses :mod:`avocado.utils.process`
can transparently inspect processes during test run time.

API
---

Avocado's GDB module, provides three main classes that lets a test writer
interact with a `gdb` process, a `gdbserver` process and also use the GDB
remote protocol for interaction with a remote target.

Please refer to :mod:`avocado.gdb` for more information.

Example
~~~~~~~

Take a look at ``examples/tests/modify_variable.py`` test::

    def action(self):
        """
        Execute 'print_variable'.
        """
        path = os.path.join(self.srcdir, 'print_variable')
        app = gdb.GDB()
        app.set_file(path)
        app.set_break(6)
        app.run()
        self.log.info("\n".join(app.read_until_break()))
        app.cmd("set variable a = 0xff")
        app.cmd("c")
        out = "\n".join(app.read_until_break())
        self.log.info(out)
        app.exit()
        self.assertIn("MY VARIABLE 'A' IS: ff", out)

You can see that instead of running the binary using ``process.run`` we invoke
``gdb.GDB``. This allows us to automate the interaction with the GDB in means
of setting breakpoints, executing commands and querying for output.

When you check the output (``--show-job-log``) you can see that despite
declaring the variable as 0, ff is injected and printed instead.


Transparent Debugging Usage
---------------------------

This feature is implemented as a plugin, that adds the ``--gdb-run-bin``
option to the avocado ``run`` command.

Example
~~~~~~~

The simplest way is to just run
``avocado run --gdb-run-bin=doublefree examples/tests/doublefree.py``, which
wraps each executed binary with name ``doublefree`` inside GDB server and
stops at the binary entry point.

Optionally you can specify single breakpoint using
``--gdb-run-bin=doublefree:$breakpoint`` (eg: ``doublefree:1``) or just
``doublefree:`` to stop only when an interruption happens (eg: SIGABRT).

It's worth mentioning that when breakpoint is not reached, the test finishes
without any interruption. This is helpful when you identify regions where you
should never get in your code, or places which interests you and you can run
your code in production and gdb variants. If after a long time you get to this
place, the test notifies you and you can investigate the problem. This is
demonstrated in ``examples/tests/doublefree_nasty.py`` test. To unveil the
power of Avocadu, run this test using
``avocado run --gdb-run-bin=doublefree: examples/tests/doublefree_nasty.py --gdb-prerun-commands examples/tests/doublefree_nasty.py.data/gdb_pre --multiplex examples/tests/doublefree_nasty.py.data/iterations.yaml``,
which executes 100 iterations of this test while setting all breakpoints from
the ``examples/tests/doublefree_nasty.py.data/gdb_pre`` file (you can specify
whatever GDB supports, not only breakpoints).

As you can see this test usually passes, but once in a while it gets into
the problematic area. Imagine this is very hard to spot (dependent on HW
registers, ...) and this is one way to combine regular testing and the
possibility of debugging hard-to-get parts of your code.

Caveats
~~~~~~~

Currently, when using the Avocado GDB plugin, that is, when using the
`--gdb-run-bin` option, there are some caveats you should be aware of:

* It is not currently compatible with Avocado's `--output-check-record` feature
* There's no way to perform proper input to the process, that is, manipulate its `STDIN`
* The process `STDERR` content is mixed with the content generated by `gdbserver` on its
  own `STDERR` (because they are in fact, the same thing)

But, you can still depend on the process `STDOUT`, as exemplified by this fictional
test::

 from avocado import test
 from avocado.utils import process

 class HelloOutputTest(test.Test):

     def action(self):
         result = process.run("/path/to/hello", ignore_status=True)
         self.assertIn("hello\n", result.stdout)

If run under GDB or not, `result.stdout` behavior and content is expected to be the same.

Reasons for the caveats
~~~~~~~~~~~~~~~~~~~~~~~

There are a two basic reasons for the mentioned caveats:

* The architecture of Avocado's GDB feature
* GDB's own behavior and limitations

When using the Avocado GDB plugin, that is, `--gdb-run-bin`, avocado runs a `gdbserver` instance
transparently and controls it by means of a `gdb` process. When a given event happens, say a
breakpoint is reached, it disconnects its own `gdb` from the server, and allows the user to use
a standard `gdb` to connect to the `gdbserver`. This provides a natural and seamless user experience.

But, `gdbserver` has some limitations at this point, including:

* Not being able to set a controlling `tty`
* Not separating its own `STDERR` content from the application being run

These limitations are being addressed both on Avocado and GDB, and will be resolved in future avocado
versions.

Workaround
~~~~~~~~~~

If the application you're running as part of your test can read input from alternative
sources (including devices, files or the network) and generate output likewise, then
you should not be further limited.
