Debugging with GDB
==================

Avocado has two levels of GDB support, one by using the Avocado GDB APIs
to fire up GDB and interact with it, and other by transparently debugging
binaries inside the GNU Debugger based on command line only options. This
later option means that any test that uses :mod:`avocado.utils.process`
can transparently inspect processes during test run time.

API
---

Avocado's GDB module, provides three main classes that lets a test writer
interact with a `gdb` process, a `gdbserver` process and also use the GDB
remote protocol for interaction with a remote target.

Please refer to :mod:`avocado.gdb` for more information.


Transparent Debugging Usage
---------------------------

This feature is implemented as a plugin, that adds the `--gdb-run-bin` option
to the avocado `run` command. For a detailed explanation please consult the
avocado man page.

Caveats
~~~~~~~

Currently, when using the Avocado GDB plugin, that is, when using the
`--gdb-run-bin` option, there are some caveats you should be aware of:

* It is not currently compatible with Avocado's `--output-check-record` feature
* There's no way to perform proper input to the process, that is, manipulate its `STDIN`
* The process `STDERR` content is mixed with the content generated by `gdbserver` on its
  own `STDERR` (because they are in fact, the same thing)

But, you can still depend on the process `STDOUT`, as exemplified by this fictional
test::

 from avocado import test
 from avocado.utils import process

 class HelloOutputTest(test.Test):

     def action(self):
         result = process.run("/path/to/hello", ignore_status=True)
         self.assertIn("hello\n", result.stdout)

If run under GDB or not, `result.stdout` behavior and content is expected to be the same.

Reasons for the caveats
~~~~~~~~~~~~~~~~~~~~~~~

There are a two basic reasons for the mentioned caveats:

* The architecture of Avocado's GDB feature
* GDB's own behavior and limitations

When using the Avocado GDB plugin, that is, `--gdb-run-bin`, avocado runs a `gdbserver` instance
transparently and controls it by means of a `gdb` process. When a given event happens, say a
breakpoint is reached, it disconnects its own `gdb` from the server, and allows the user to use
a standard `gdb` to connect to the `gdbserver`. This provides a natural and seamless user experience.

But, `gdbserver` has some limitations at this point, including:

* Not being able to set a controlling `tty`
* Not separating its own `STDERR` content from the application being run

These limitations are being addressed both on Avocado and GDB, and will be resolved in future avocado
versions.

Workaround
~~~~~~~~~~

If the application you're running as part of your test can read input from alternative
sources (including devices, files or the network) and generate output likewise, then
you should not be further limited.
