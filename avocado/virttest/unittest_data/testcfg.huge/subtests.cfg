# This file is just a sample config file used for the config parser unit tests
# Do not edit, auto generated file from subtests config
variants:
    - unattended_install:
        virt_test_type = qemu libvirt
        type = unattended_install
        start_vm = no
        kill_vm = yes
        kill_vm_gracefully = yes
        kill_vm_on_error = yes
        shutdown_cleanly = yes
        shutdown_cleanly_timeout = 120
        force_create_image = yes
        guest_port_unattended_install = 12323
        kernel = vmlinuz
        initrd = initrd.img
        # Throw errors if guest screen is inactive
        inactivity_watcher = error
        # Inactivity treshold to error the test
        inactivity_treshold = 1800
        # Set migrate_background to yes to run migration in parallel
        # migrate_background = yes
        image_verify_bootable = no
    
        # Way of delivering ks file into the guest
        variants:
            # Additional iso with kickstart is attached into the guest
            - extra_cdrom_ks:
                only Linux
                no JeOS
                unattended_delivery_method = cdrom
                cdroms += " unattended"
                drive_index_unattended = 1
                drive_index_cd1 = 2
            # Kickstart is packed into the installation iso
            - in_cdrom_ks:
                no JeOS
                only Linux, unattended_install.cdrom
                unattended_delivery_method = integrated
            # Autotest starts simple http server providing kickstart
            - http_ks:
                no JeOS
                only Linux
                unattended_delivery_method = url
            # Image with kickstart is attached into the guest as floppy drive
            - floppy_ks:
                no JeOS
                only Linux
                unattended_delivery_method = floppy
            # Only perform a libvirt import. No cdroms, no floppies, no nothing
            - import:
                virt_test_type = libvirt
                no cdrom
                cdroms = ""
                floppy = ""
    
        variants:
            # Install guest from cdrom
            - cdrom:
                # TODO: is this needed for both kvm and libvirt?
                # This option is only used in windows installation case,
                # since linux use kernel/initrd option of qemu.
                boot_once = d
                medium = cdrom
                redirs += " unattended_install"
            # Install guest from http/ftp url
            - url:
                no JeOS
                only Linux
                medium = url
                url = REPLACE_THIS_WITH_TREE_URL
            # Install guest from nfs nfs_server:nfs_dir
            - nfs:
                no JeOS
                only Linux
                medium = nfs
                nfs_server = REPLACE_THIS_WITH_NFS_SERVER
                nfs_dir = REPLACE_THIS_WITH_NFS_DIRECTORY
            # Install guest with a remote kickstart
            - remote_ks:
                no JeOS
                only Linux
                medium = url
                # TODO: does kvm need to prefix this with '--append'?
                extra_params = " ks=REPLACE_THIS_WITH_URL_OF_KS"
                url = REPLACE_THIS_WITH_TREE_URL
            # Install guest using pxe/tftp  (virt-install --pxe)
            - pxe:
                no JeOS
                only Linux
                medium = pxe
            # Install guest using kernel/initrd pair from directory
            - kernel_initrd:
                no JeOS
                only Linux
                medium = kernel_initrd
            - import:
                virt_test_type = libvirt
                no extra_cdrom_ks
                medium = import
                force_create_image = no
                create_image = no
    - 9p: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        no JeOS
        only Linux
        type = 9p
        9p_mount_dir = /root/mount1
        9p_posix_acl = yes
        9p_guest_cache = yes
        9p_proto_version = 9p2000.L
        test_timeout = 1800
        variants:
            - 9p_ci:
                test_control_file = 9p-ci.control
                test_timeout = 1800
    - balloon_check: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        no Win2000, Fedora.8, Fedora.9, Fedora.10, RHEL.3, RHEL.4, Unix, livecd
        type = balloon_check
        extra_params += " -balloon virtio"
        iterations = 5
        variants:
           - @base:
    
           - balloon-migrate:
               sub_balloon_test_enlarge = "migration"
               sub_balloon_test_evict = "migration"
               migration_test_command = help
               migration_bg_command = "cd /tmp; nohup tcpdump -q -i any -t ip host localhost"
               migration_bg_check_command = pgrep tcpdump
               migration_bg_kill_command = pkill tcpdump
               kill_vm_on_error = yes
               iterations = 2
               used_mem = 1024
               mig_timeout = 3600
               migration_protocol = "tcp"
           - balloon-migrate-x-rdma:
               sub_balloon_test_enlarge = "migration"
               sub_balloon_test_evict = "migration"
               migration_test_command = help
               migration_bg_command = "cd /tmp; nohup tcpdump -q -i any -t ip host localhost"
               migration_bg_check_command = pgrep tcpdump
               migration_bg_kill_command = pkill tcpdump
               kill_vm_on_error = yes
               iterations = 2
               used_mem = 1024
               mig_timeout = 3600
               migration_protocol = "x-rdma"
           - balloon-migrate-rdma:
               sub_balloon_test_enlarge = "migration"
               sub_balloon_test_evict = "migration"
               migration_test_command = help
               migration_bg_command = "cd /tmp; nohup tcpdump -q -i any -t ip host localhost"
               migration_bg_check_command = pgrep tcpdump
               migration_bg_kill_command = pkill tcpdump
               kill_vm_on_error = yes
               iterations = 2
               used_mem = 1024
               mig_timeout = 3600
               migration_protocol = "rdma"
           - balloon-shutdown_enlarge:
               sub_balloon_test_enlarge = "shutdown"
               shutdown_method = shell
               kill_vm = yes
               kill_vm_gracefully = no
               check_img = yes
           - balloon-shutdown_evict:
               shutdown_method = shell
               kill_vm = yes
               kill_vm_gracefully = no
               sub_balloon_test_evict = "shutdown"
    - block_mirror:
        virt_test_type = qemu
        type = block_mirror
        block_mirror_cmd = drive_mirror
    - block_stream:
        virt_test_type = qemu
        type = block_stream
        alive_test_cmd = uname -a
    - cdrom_test: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only Linux
        type = cdrom
        cdrom_cd1 = orig.iso
        start_vm = no
        kill_vm_on_error = yes
        max_times = 20
        # test whether cdrom is unlocked <300s after boot
        cdrom_test_autounlock = no
        # test the tray status
        cdrom_test_tray_status = yes
        # wait before eject $cdrom (let OS initialize cdrom ...)
        workaround_eject_time = 0
    - cgroup:
        virt_test_type = qemu
        only Linux
        type = cgroup
        requires_root = yes
        cgroup_test_time = 60
        cgroup_limit = 0.1
        # rmmod scsi_debug instead of writing into /sys/../add_host (safer)
        cgroup_rmmod_scsi_debug = "yes"
        variants:
            - blkio_bandwidth:
                # Test creates VMs with disks according to weights
                vms = ""
                # problem with multiple preprocess, turn off the screendumps
                take_regular_screendumps = "no"
                extra_params += " -snapshot"
                cgroup_test = "blkio_bandwidth"
                # cgroup_test_time, cgroup_weights, cgroup_limit{ ,_read,_write}
                # cgroup_weights = "[100, 1000, 500]"
            - blkio_throttle:
                # Test creats VMs with disks according to speeds
                vms = ""
                # problem with multiple preprocess, turn off the screendumps
                take_regular_screendumps = "no"
                extra_params += " -snapshot"
                cgroup_test = "blkio_throttle"
                # cgroup_test_time, cgroup_limit{ ,_read,_write}, cgroup_speeds
                # cgroup_speeds = [1024, 2048, 4096, 8192]
            - blkio_throttle_multi:
                # Test creats VMs with disks according to speeds
                vms = ""
                # problem with multiple preprocess, turn off the screendumps
                take_regular_screendumps = "no"
                extra_params += " -snapshot"
                cgroup_test = "blkio_throttle_multi"
                # cgroup_test_time, cgroup_limit{ ,_read,_write}, cgroup_speeds
                # cgroup_speeds = "[[0, 1024, 0, 2048, 0, 4096],"
                # cgroup_speeds += "[1024, 1024, 1024, 1024, 1024, 1024]]"
            - cpu_cfs_util:
                # Test creats VMs according to no_host_cpus
                vms = ""
                # problem with multiple preprocess, turn off the screendumps
                take_regular_screendumps = "no"
                extra_params += " -snapshot"
                cgroup_test = "cpu_cfs_util"
                # cgroup_test_time, cgroup_limit
            - cpu_share:
                # Test creats VMs according to smp and cgroup_speeds
                vms = ""
                # problem with multiple preprocess, turn off the screendumps
                take_regular_screendumps = "no"
                extra_params += " -snapshot"
                cgroup_test = "cpu_share"
                # cgroup_use_max_smp, cgroup_test_time, cgroup_speeds
                cgroup_use_max_smp == 'yes'
                # cgroup_speeds = "[1000, 10000, 100000]"
            - cpuset_cpus:
                extra_params += " -snapshot"
                cgroup_test = "cpuset_cpus"
                # cgroup_use_half_smp, cgroup_test_time, cgroup_limit, cgroup_cpuset, cgroup_verify
                cgroup_use_half_smp = 'yes'
                cgroup_test_time = 10
                # cgroup_cpuset = [[None, '0,3', '1', '2', '1-2'],
                # cgroup_cpuset += [None, '0', '1', '0-1', '0-1']]
                # cgroup_verify = [[50, 100, 100, 50], [100, 100, 5, 5]]
            - cpuset_cpus_switching:
                cgroup_test = "cpuset_cpus_switching"
                # cgroup_test_time
            - cpuset_mems_switching:
                cgroup_test = "cpuset_mems_switching"
                # cgroup_test_time, cgroup_cpuset_mems_mb
            - devices_access:
                cgroup_test = "devices_access"
            - freezer:
                cgroup_test = "freezer"
                # cgroup_test_time
            - memory_limit:
                # Test creats VMs
                cgroup_test = "memory_limit"
                # cgroup_memory_limit_kb(4kb aligned)
                # cgroup_memory_limit_kb = 2097152
            - memory_memsw_limit:
                # Test creats VMs
                cgroup_test = "memory_memsw_limit"
                # cgroup_memory_limit_kb(4kb aligned)
                # cgroup_memory_limit_kb = 2097152
            - memory_move:
                cgroup_test = "memory_move"
                restart_vm = "yes"
                # cgroup_test_time, cgroup_memory_move_mb
                # cgroup_memory_move_mb = 2048
    - chardev_hotplug: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        virt_test_type = qemu
        type = chardev_hotplug
        monitor_type = qmp
        restart_vm = yes
        kill_vm = yes
    - cpu_hotplug_test: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = cpu_hotplug
        cpu_hotplug_timeout = 600
        n_cpus_add = 1
        kill_vm = yes
        iterations = 5
        onoff_iterations = 100
    - cpuflags: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        no JeOS
        type = cpuflags
        extra_params += " -snapshot"
        auto_cpu_model = no
        #Disable all unnecessary vms.
        vms = ""
        #Try to start guest with all flags which are supported by host.
        all_host_supported_flags = "no"
    
        #If cpu_model is "" or isn't defined test try test all cpu models,
        #which host supports.
        cpu_model = ""
    
        #Cpumodels defined in blacklist are not tested.
        #Works only if cpu_model is not defined.
        cpu_model_blacklist = ""
        64:
            cpu_model_blacklist += " 486 kvm32 qemu32 pentium pentium2"
            cpu_model_blacklist += " pentium3 coreduo n270"
        guest_spec_flags = "fxsr_opt hypervisor ds pdpe1gb osxsave svm"
        host_spec_flags = "pbe tm ds_cpl monitor acpi dtes64 ht tm2 xtpr est pdcm smx"
        variants:
            - interface:
                variants:
                    - qemu_cpu_model:
                        test_type = "test_qemu_cpu_model"
                    - qemu_cpu_dump:
                        test_type = "test_qemu_dump"
                    - qemu_cpu_cpuid:
                        test_type = "test_qemu_cpuid"
            - boot_guest:
                variants:
                    - qemu_boot_cpu_model:
                        test_type = "test_boot_cpu_model"
                    - qemu_boot_cpu_model_and_flags:
                        test_type = "test_boot_cpu_model_and_additional_flags"
                    - qemu_warn_boot_check_cpu_model:
                        test_type = "test_boot_warn_with_host_unsupported_flags"
                    - qemu_boot_fail_cpu_model:
                        test_type = "test_fail_boot_with_host_unsupported_flags"
            - stress_guest:
                variants:
                    - qemu_test_boot_guest_and_try_flags_under_load:
                        test_type = "test_boot_guest_and_try_flags_under_load"
                    - qemu_test_online_offline_guest_CPUs:
                        test_type = "test_online_offline_guest_CPUs"
                    - qemu_test_migration_with_additional_flags:
                        test_type = "test_migration_with_additional_flags"
    
    - enospc: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        no JeOS
        type = enospc
        start_vm = no
        images += " stg"
        drive_werror = stop
        drive_cache = none
        image_name_stg = enospc
        image_format_stg = qcow2
        image_boot_stg = no
        image_snapshot_stg = no
        check_image_stg = no
        vgtest_name = vg_kvm_test_enospc
        lvtest_name = lv_kvm_test_enospc
        background_cmd = "nohup dd if=/dev/zero of=%s bs=1024 &"
        kill_vm = yes
    - floppy_test: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only Linux
        type = floppy
        start_vm = no
        floppies = "fl"
        floppy_name = images/test_floppy.img
    - fullscreen_setup:
        virt_test_type = qemu
        no JeOS
        type = fullscreen_setup
        vms = vm1 vm2
        guest_vm = vm1
        client_vm = vm2
        image_name_vm2 = client_vm
        display_vm2 = vnc
        vga_vm2 = cirrus
        virtio_ports_vm1 = "vdagent"
        virtio_port_type_vm1 = "serialport"
        virtio_port_chardev_vm1 = "spicevmc"
        virtio_port_name_prefix_vm1 = "com.redhat.spice."
    
        variants:
            - RHEL:
                variants:
                    # This is current solution of handling
                    # multiple guests running exact same OS
                    -6.3.x86_64:
                        image_name_vm2 = images/rhel6devel-64_client
                    -6.3.i386:
                        image_name_vm2 = images/rhel6devel-32_client
    - getfd: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = getfd
        restart_vm = yes
        kill_vm = yes
        number_of_files = 900
    - hdparm: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only Linux
        type = hdparm
        get_disk_cmd = \ls /dev/[vhs]da
        low_status_cmd = hdparm -a64 -d0 -u0 %s
        device_cache_read_cmd = hdparm -tT %s
        high_status_cmd = hdparm -a256 -d1 -u1 %s
        cmd_timeout = 540
        virtio_blk:
            get_disk_cmd = \ls /dev/vda
            low_status_cmd = hdparm -a32 -r0 %s
            high_status_cmd = hdparm -a256 -r1 %s
    - image_copy:
        virt_test_type = qemu
        no JeOS
        type = image_copy
        vms = ''
        parallel = no
        profilers =
    - jumbo: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only Linux
        requires_root = yes
        type = jumbo
    - kernel_install:
        virt_test_type = qemu
        only Linux
        type = kernel_install
        variants:
            ## Example for other installation methods
            #- koji:
            #    install_type = koji
            #    kernel_dep_pkgs = "linux-firmware module-init-tools"
            #    kernel_koji_tag = f17-updates
            #- rpm:
            #    install_type = rpm
                 # These 2 parameters can be url.
            #    kernel_rpm_path = "kernel-3.4.4-3.fc17.x86_64.rpm"
            #    kernel_deps_rpms = "linux-firmware-20120510-0.3.git375e954.fc17.noarch.rpm"
            #    file_checklist = kernel_rpm_path kernel_deps_rpms
            #- git:
            #    install_type = git
            #    kernel_git_repo = ""
            #    kernel_git_repo_base = ""
            #    kernel_git_branch = ""
            #    kernel_git_commit = ""
            #    kernel_patch_list = ""
            #    kernel_config = ""
            #    kerne_config_list = ""
            - @tar:
                install_type = tar
                kernel_src_pkg = "http://www.kernel.org/pub/linux/kernel/v3.0/linux-3.4.tar.bz2"
                # Remember to update this config file to your own.
                kernel_config = "/boot/config--3.4.4-3.fc17.x86_64"
                kernel_patch_list = "http://www.kernel.org/pub/linux/kernel/v3.0/patch-3.4.4.bz2"
                file_checklist = kerne_src_pkg kernel_config kernel_patch_list
                kernel_tag = "3.4.4"
                # The fedora default kernel config would take very long time to compile.
                test_timeout_install = 3600
    - ksm_overcommit: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only Linux
        requires_root = yes
        # Don't preprocess any vms as we need to change its params
        vms = ''
        image_snapshot = yes
        kill_vm_gracefully = no
        type = ksm_overcommit
        # Make host use swap (a value of 'no' will turn off host swap)
        ksm_swap = yes
        no hugepages
        # Overcommit of host memmory
        ksm_overcommit_ratio = 3
        # Max parallel runs machine
        ksm_parallel_ratio = 4
        # Host memory reserve (default - best fit for used mem)
        # ksm_host_reserve = 512
        # ksm_guest_reserve = 1024
        variants:
            - ksm_serial:
                ksm_mode = "serial"
            - ksm_parallel:
                ksm_mode = "parallel"
    - migrate: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = migration
        migration_test_command = help
        migration_bg_command = "cd /tmp; nohup tcpdump -q -i any -t ip host localhost"
        migration_bg_check_command = pgrep tcpdump
        migration_bg_kill_command = pkill tcpdump
        kill_vm_on_error = yes
        iterations = 2
        used_mem = 1024
        mig_timeout = 3600
        # you can uncomment the following line to enable the state
        # check
        # vmstate_check = yes
        variants:
            - tcp:
                migration_protocol = "tcp"
            - x-rdma:
                migration_protocol = "x-rdma"
            - rdma:
                migration_protocol = "rdma"
            - unix:
                migration_protocol = "unix"
            - exec:
                migration_protocol = "exec"
            - fd:
                migration_protocol = "fd"
            - mig_cancel:
                migration_protocol = "tcp"
                mig_cancel = yes
                only migrate..default
            - mig_cancel_x_rdma:
                migration_protocol = "x-rdma"
                mig_cancel = yes
                only migrate..default
            - mig_cancel_rdma:
                migration_protocol = "rdma"
                mig_cancel = yes
                only migrate..default
        variants:
            - @default:
            - with_speed_measurement:
                no JeOS
                # migration speed in bytes. Default scaler is M (350 == 350M)
                only Linux
                mig_speed = 125M
                # accuracy of mig_speed
                # speed_range = (mig_speed+-(mig_speed*mig_speed_accuracy))
                # if real_mig_speed is on in speed_range it raises Test warning.
                mig_speed_accuracy = 0.3
                pre_migrate = "set_speed_and_install"
                type = migration_with_speed_measurement
                exec:
                    # Exec migration is pretty slow compared to other protos
                    mig_speed = 50M
            - with_set_speed:
                mig_speed = 1G
                pre_migrate = "mig_set_speed"
            - with_reboot:
                iterations = 1
                type = migration_with_reboot
            - with_file_transfer:
                no JeOS
                iterations = 1
                type = migration_with_file_transfer
            - with_autotest:
                no JeOS
                only Linux
                type = autotest_control
                migrate_background = yes
                test_timeout = 1800
                variants:
                    - dbench:
                        test_control_file = dbench.control
                    - stress:
                        test_control_file = stress.control
                    - monotonic_time:
                        test_control_file = monotonic_time.control
    
    - module_probe:
        virt_test_type = qemu
        type = module_probe
        requires_root = yes
        # You can specify your own module list, though it is not needed usually.
        # mod_list = kvm
        load_count = 100
        vms = ''
        profilers = ''
        take_regular_screendumps = no
    - multi_disk: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = multi_disk
        force_create_image = yes
        force_create_image_image1 = no
        remove_image = yes
        remove_image_image1 = no
        cmd_timeout = 1000
        black_list = C: D:
        start_vm = no
        variants:
            - signal_repeat:
                images += " stg"
                image_format_stg = qcow2
                image_name_stg = storage
                image_size_stg = 1G
                n_repeat = 10
            - max_disk:
                only virtio_blk
                # TODO: confirm this works with libvirt
                usbs = ''
                usb_devices = ''
                stg_image_num = 23
                stg_image_size = 1G
                stg_image_boot = no
                # other variants.
                # stg_image_format = qcow2
                # stg_drive_format = virtio
            - all_drive_format_types:
                stg_image_size = 1M
                stg_params = "drive_format:ide,scsi,virtio,scsi-hd,usb2"
                usbs += " default-ehci"
                usb_type_default-ehci = usb-ehci
            - virtio_scsi_variants:
                # Decrease length of the command
                stg_image_name = '/tmp/%s'
                stg_image_size = 1M
                stg_params = "drive_format:scsi-disk "
                variants:
                    - @passthrough:
                        # We need to unload scsi_debug modules used by VM
                        kill_vm = yes
                        force_create_image = no
                        pre_command = "modprobe scsi_debug && echo 9 > /sys/bus/pseudo/drivers/scsi_debug/add_host"
                        post_command = "rmmod scsi_debug"
                        stg_params += "image_raw_device:yes "
                        stg_params += "image_format:raw "
                        stg_params += "indirect_image_select:range(-9,0) "
                        variants:
                            - block:
                                stg_params += "image_name:/dev/sd* "
                            - generic:
                                stg_params += "drive_format:scsi-generic "
                                stg_params += "image_name:/dev/sg* "
                    - multi_lun:
                        stg_params += "drive_lun:range(0,16383,63) "
                    - multi_scsiid_lun:
                        stg_params += "drive_scsiid:range(0,255,1,3) "
                        stg_params += "drive_lun:range(0,16383,8191) "
                    - multi_bus_scsiid_lun:
                        stg_params += "drive_bus:range(0,15,1,9) "
                        stg_params += "drive_scsiid:range(0,255,127,3) "
                        stg_params += "drive_lun:range(0,16383,8191) "
            - debug_params:
                # Remove this to execute this test-params-devel test
                no multi_disk
                # Dont run the actual test, only show the disk setup
                multi_disk_params_only = yes
                stg_image_name = '/tmp/%s'
                stg_image_size = 1M
                stg_params += "list_params:item1,item2,item3 "
                stg_params += "simplerange:range(55) "
                stg_params += "fullrange:range(first,last,step,multiple_items) "
                stg_params += "range_0-all_disk:range(n) "
    - @multi_host:
        virt_test_type = qemu
        # params which ends with hostx will be sended only to machinex in autoserv
        # test command ./autoserv -m machine1,machine2 multi_host.srv
        # this mean host1 parmas will be send to machine1
        #           host2 params will be send to machine2 etc..
    
        remove_image_on_check_error = yes
        force_image_clone = no
        virt_test_type = kvm
        no JeOS
        variants:
            - migrate_multi_host: install setup image_copy unattended_install.cdrom
                type = migration_multi_host
                vms = "vm1"
                start_vm = no
                migration_test_command = help
                migration_bg_command = "cd /tmp; nohup tcpdump -q -i any -t ip host localhost"
                migration_bg_check_command = pgrep tcpdump
                migration_bg_kill_command = pkill tcpdump
                kill_vm_on_error = yes
                iterations = 2
                used_mem = 1024
                mig_timeout = 480
                disk_prepare_timeout = 360
                comm_port = 13234
                regain_ip_cmd = killall dhclient; sleep 10; dhclient;
                variants:
                    #Migration protocol.
                    - x-rdma:
                        mig_protocol = "x-rdma"
                    - rdma:
                        mig_protocol = "rdma"
                    - tcp:
                        mig_protocol = "tcp"
                    - fd:
                        mig_protocol = "fd"
                    - exec:
                        mig_protocol = "exec"
    
                variants:
                    #Time when start migration
                    - after_login_vm:
                        paused_after_start_vm = no
                    - early_boot_vm:
                        no measure_migration_speed
                        login_timeout = 420
                        paused_after_start_vm = yes
                        variants:
                            - timeout_0:
                                start_migration_timeout = 0
                            - timeout_6:
                                start_migration_timeout = 6
    
                variants:
                    - mig_online:
                        mig_offline = no
                    - mig_offline:
                        mig_offline = yes
    
                variants:
                    - @vhost_src_no_dst_no:
                        netdev_extra_params_host1 = ""
                        netdev_extra_params_host2 = ""
                    - vhost_src_yes_dst_yes:
                        netdev_extra_params_host1 = "vhost=on"
                        netdev_extra_params_host2 = "vhost=on"
                    - vhost_src_yes_dst_no:
                        netdev_extra_params_host1 = "vhost=on"
                        netdev_extra_params_host2 = ""
                    - vhost_src_no_dst_yes:
                        netdev_extra_params_host1 = ""
                        netdev_extra_params_host2 = "vhost=on"
    
                variants:
                    # Migration properties
                    - @default:
                        type = migration_multi_host
                    - timedrift:
                        rtc_drift = "slew"
                        type = migration_multi_host_timedrift
                        create_file = "touch /tmp/timedrift_test"
                        host_sync_time_cmd = "ntpdate -b pool.ntp.org"
                        migrate_count = 6
                        migration_timeout = 240
                        time_diff_limit = 1.5
                    - cancel_with_delay:
                        type = migration_multi_host_cancel
                        only after_login_vm
                        only mig_online
                        cancel_delay = 10
                    - measure_speed:
                        only Linux
                        only after_login_vm
                        only mig_online
                        not_wait_for_migration = yes
                        mig_speed = 1G
                        type = migration_multi_host_with_speed_measurement
                    - with_file_transfer:
                        only Linux
                        only after_login_vm
                        type = migration_multi_host_with_file_transfer
                        only mig_online
                        comm_port = 13234
                        del_file_with_err = yes
                        #path where file is stored on guest.
                        guest_path = "/tmp/file"
                        #size of generated file in MB.
                        file_size = 256
                        transfer_timeout = 440
                        #Transfer speed in Mb
                        transfer_speed = 300
                        #Count of migration during file transfer.
                        migrate_count = 3
                        regain_ip_cmd = ""
                    - downtime:
                        only after_login_vm
                        sub_type = downtime
                        only mig_online
                        # downtime in seconds.
                        max_downtime = 10
                        not_wait_for_migration = yes
                        type = migration_multi_host_downtime_and_speed
                    - speed:
                        only after_login_vm
                        sub_type = speed
                        only mig_online
                        # speed in Mb
                        min_migration_speed = 10M
                        max_migration_speed = 500M
                        # time interval in seconds.
                        # set how fast is migration speed changed.
                        change_speed_interval = 1
                        # speed is changed x time per min max interval
                        count_of_change = 10
                        not_wait_for_migration = yes
                        type = migration_multi_host_downtime_and_speed
                    - mig_stop_during:
                        only after_login_vm
                        sub_type = stop_during
                        only mig_online
                        wait_before_stop = 3
                        not_wait_for_migration = no
                        type = migration_multi_host_downtime_and_speed
                    - ping-pong-stress:
                        # amount of memory used for migration stress
                        # amount of memory shouldn't be too high otherwise
                        # migration will never end
                        only after_login_vm
                        only mig_online
                        type = migration_multi_host_ping_pong
                        # stress_memory should be less than troughput of
                        # migration
                        stress_memory = 50
                        migrate_count = 3
                        migration_timeout = 240
                        variants:
                            - @no_stress:
                                stress_type = none
                            - cpu_memory:
                                stress_type = cpu_memory
                            - disk:
                                disk_usage = 200
                                stress_type = disk
                            - all:
                                stress_type = all
                    - host_mig_offline:
                        only exec
                        only mig_offline
                        host_mig_offline = yes
                        type = migration_multi_host
                    - dest-problem-test:
                        variants:
                            - firewall-block:
                                type = migration_multi_host_firewall_block
                                only mig_online
                                not_wait_for_migration = yes
                                only after_login_vm..tcp
                                variants:
                                    - long_wait:
                                        sub_type = long_wait
                                        mig_timeout = 1200
                                        variants:
                                            - @wait_util_end:
                                                mig_cancel = no
                                            - mig_cancel:
                                                mig_cancel = yes
                                    - short_interrupt:
                                        sub_type = short_interrupt
    
    
            - cpuflags_multi_host:
                type = cpuflags
                test_type = test_multi_host_migration
                vms = "vm1"
                start_vm = no
                #Try to start guest with all flags which are supported by host.
                all_host_supported_flags = "no"
                cpu_model = "core2duo:sse3"
                guest_spec_flags = "fxsr_opt hypervisor ds pdpe1gb osxsave svm"
                host_spec_flags = "pbe tm ds_cpl monitor acpi dtes64 ht tm2 xtpr est pdcm smx"
                mig_timeout = 4800
                kill_vm_on_error = yes
                disk_prepare_timeout = 360
                comm_port = 13234
                regain_ip_cmd = killall dhclient; sleep 10; dhclient;
                auto_cpu_model = no
    
        only default_machine_types
        # For RHEL machine type.
        #only rhel_machine_types
    
        variants:
            - @default_machine_types:
                variants:
                    -@pc:
                        machine_type = "pc"
                    -pc-0.14:
                        machine_type = "pc-0.14"
                    -pc-0.13:
                        machine_type = "pc-0.13"
                    -pc-0.12:
                        machine_type = "pc-0.12"
                    -pc-0.11:
                        machine_type = "pc-0.11"
                    -pc-0.10:
                        machine_type = "pc-0.10"
                    -isapc:
                        machine_type = "isapc"
    
            - @rhel_machine_types:
                variants:
                    -@pc:
                        machine_type = "pc"
                    - rhel5.4.0:
                        machine_type = "rhel5.4.0"
                    - rhel5.4.4:
                        machine_type = "rhel5.4.4"
                    - rhel5.5.0:
                        machine_type = "rhel5.5.0"
                    - rhel6.0.0:
                        machine_type = "rhel6.0.0"
                    - rhel6.2.0:
                        machine_type = "rhel6.2.0"
                    - rhel6.3.0:
                        machine_type = "rhel6.3.0"
    
    - multi_vms_file_transfer:
        virt_test_type = qemu
        only Linux
        type = multi_vms_file_transfer
    - negative_create:
        virt_test_type = qemu
        virt_test_type = qemu libvirt
        no JeOS
        type = negative_create
        start_vm = no
    - nfs_corrupt:
        virt_test_type = qemu
        only Linux
        type = nfs_corrupt
        requires_root = yes
        start_vm = no
        images += " stg"
        image_size_stg = "10G"
        image_format_stg = "qcow2"
        create_image_stg = no
        force_create_image_stg = no
        remove_image_stg = yes
        drive_werror = stop
        drive_cache = none
        kill_vm = yes
        post_command_noncritical = yes
        wait_paused_timeout = 120
        nfs_stat_chk_re = "running"
    - nic_hotplug: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        pci_type = nic
        reference_cmd = lspci
        find_pci_cmd = 'lspci | tail -n1'
        pci_test_cmd = 'nslookup www.redhat.com'
        wait_secs_for_hook_up = 3
        run_dhclient = no
        variants:
            - nic_8139:
                pci_model = rtl8139
                match_string = "8139"
            - nic_virtio:
                #TODO: Confirm this works with libvirt
                pci_model = virtio-net-pci
                match_string = "Virtio network device"
            - nic_e1000:
                pci_model = e1000
                match_string = "Gigabit Ethernet Controller"
        variants:
            - default:
                type = pci_hotplug
            - additional:
                type = nic_hotplug
            - migration:
                # For now, migration + networking only works
                # with bridge (no usermode)
                requires_root = yes
                type = migration_after_nichotplug
    - nmi_bsod_catch:
        virt_test_type = qemu
        type = nmi_bsod_catch
        only Windows
        config_cmds = config_cmd1, config_cmd2, config_cmd3, config_cmd4, config_cmd5, config_cmd6
        # enable AutoReboot, guest will reboot after finishing create dump file.
        config_cmd1 = reg add HKLM\System\CurrentControlSet\Control\CrashControl /v AutoReboot /d 1 /t REG_DWORD /f
        # enable memory dump.
        config_cmd2 = reg add HKLM\System\CurrentControlSet\Control\CrashControl /v CrashDumpEnabled /d 2 /t REG_DWORD /f
        # save memory dump to C:\Windows\Memory.dmp
        config_cmd3 = reg add HKLM\System\CurrentControlSet\Control\CrashControl /v DumpFile /d C:\Memory.dmp /t REG_EXPAND_SZ /f
        # enable nmi dump
        config_cmd4 = reg add HKLM\System\CurrentControlSet\Control\CrashControl /v NMICrashDump  /d 1 /t REG_DWORD /f
        config_cmd5 = reg add HKLM\System\CurrentControlSet\Control\CrashControl /v AlwaysKeepMemoryDump /d 1 /t REG_DWORD /f 
        # disable windows error reporting, it may block our test
        config_cmd6 = reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\Windows Error Reporting" /v Disabled /d 1 /t REG_DWORD /f
        manual_reboot_cmd =
        reboot_after_config = yes
        dump_path = C:\Memory.dmp
        analyze_cmd = 
        check_dump_cmd = dir C:\Memory.dmp 
        del_dump_cmd = del C:\Memory.dmp
        nmi_cmd = inject-nmi
    - nmi_watchdog: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = nmi_watchdog
        get_nmi_cmd = grep NMI /proc/interrupts
        nmi_watchdog_type = 1
        image_snapshot = yes
        only Linux
    - perf_kvm: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = perf_kvm
        requires_root = yes
        kallsyms_cmd = "cat /proc/kallsyms > /tmp/guest_kallsyms"
        modules_cmd = "cat /proc/modules > /tmp/geust_modules"
        transfer_timeout = 100
        perf_record_timeout =  100
    - performance:
        virt_test_type = qemu
        no JeOS
        type = performance
        kill_vm = yes
        variants:
            - ffsb:
                only Linux
                md5value = "cabfc1021c2ec6c6b168fefc84210891"
                images += " stg2"
                image_name_stg2 = storage2
                image_size_stg2 = 110G
                force_create_image = yes
                force_create_image_image1 = no
                test_timeout = 3600
                monitor_cmd = "mpstat -P ALL 1"
                #test_cmd = "ffsb examples/profile_everything"
                test_src = "http://cdnetworks-kr-1.dl.sourceforge.net/project/ffsb/ffsb/ffsb-6.0-rc2/ffsb-6.0-rc2.tar.bz2"
                compile_cmd = "./configure && make"
                prepare_cmd = " mount /dev/[sv]db /mnt"
                ignore_pattern = "Linux|^(\n)"
                head_pattern = "\d+:\d+:\d+\s+[AP]M\s+(\w+)\s+"
                row_pattern = "CPU"
                categories = "LargeFile Creates(256KB)|LargeFile Create(8KB)|Mail Server(8KB)|Radom Reads(8KB)|Random Writes(8KB)|Sequential Reads(256KB)|Sequential Reads(8KB)"
                threads = "1 8 16"
                variants:
                    - file_prepare:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_file_prepare.patch"
                        test_cmd = "ffsb examples/file_prepare.ffsb"
                    - large_file_creates_256k_01:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_256k_1.patch"
                        test_cmd = "ffsb examples/large_file_creates_256k_1.ffsb"
                    - large_file_creates_256k_08:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_256k_8.patch"
                        test_cmd = "ffsb examples/large_file_creates_256k_8.ffsb"
                    - large_file_creates_256k_16:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_256k_16.patch"
                        test_cmd = "ffsb examples/large_file_creates_256k_16.ffsb"
                    - large_file_creates_8k_01:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_8k_1.patch"
                        test_cmd = "ffsb examples/large_file_creates_8k_1.ffsb"
                    - large_file_creates_8k_08:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_8k_8.patch"
                        test_cmd = "ffsb examples/large_file_creates_8k_8.ffsb"
                    - large_file_creates_8k_16:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_8k_16.patch"
                        test_cmd = "ffsb examples/large_file_creates_8k_16.ffsb"
                    - mail_server_8k_01:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_mail_server_8k_1.patch"
                        test_cmd = "ffsb examples/mail_server_8k_1.ffsb"
                    - mail_server_8k_08:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_mail_server_8k_8.patch"
                        test_cmd = "ffsb examples/mail_server_8k_8.ffsb"
                    - mail_server_8k_16:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_mail_server_8k_16.patch"
                        test_cmd = "ffsb examples/mail_server_8k_16.ffsb"
                    - random_read_8k_01:
                        force_create_image = no
                        test_patch = "ffsb_random_reads_8k_1.patch"
                        test_cmd = "ffsb examples/random_reads_8k_1.ffsb"
                    - random_read_8k_08:
                        force_create_image = no
                        test_patch = "ffsb_random_reads_8k_8.patch"
                        test_cmd = "ffsb examples/random_reads_8k_8.ffsb"
                    - random_read_8k_16:
                        force_create_image = no
                        test_patch = "ffsb_random_reads_8k_16.patch"
                        test_cmd = "ffsb examples/random_reads_8k_16.ffsb"
                    - random_write_8k_01:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_random_write_8k_1.patch"
                        test_cmd = "ffsb examples/random_write_8k_1.ffsb"
                    - random_write_8k_08:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_random_write_8k_8.patch"
                        test_cmd = "ffsb examples/random_write_8k_8.ffsb"
                    - random_write_8k_16:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_random_write_8k_16.patch"
                        test_cmd = "ffsb examples/random_write_8k_16.ffsb"
                    - sequential_reads_256k_01:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_256k_1.patch"
                        test_cmd = "ffsb examples/sequential_reads_256k_1.ffsb"
                    - sequential_reads_256k_08:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_256k_8.patch"
                        test_cmd = "ffsb examples/sequential_reads_256k_8.ffsb"
                    - sequential_reads_256k_16:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_256k_16.patch"
                        test_cmd = "ffsb examples/sequential_reads_256k_16.ffsb"
                    - sequential_reads_8k_01:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_8k_1.patch"
                        test_cmd = "ffsb examples/sequential_reads_8k_1.ffsb"
                    - sequential_reads_8k_08:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_8k_8.patch"
                        test_cmd = "ffsb examples/sequential_reads_8k_8.ffsb"
                    - sequential_reads_8k_16:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_8k_16.patch"
                        test_cmd = "ffsb examples/sequential_reads_8k_16.ffsb"
                    - summary_results:
                        summary_results = "yes"
                        test = "ffsb"
    - physical_resources_check: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = physical_resources_check
        default_cpu_model = "qemu64"
        cpu_model_vendor = "AuthenticAMD"
        # The following config parameters are only for Linux guest, thay might
        # be changed in guest-os.cfg file for different guest os type.
        catch_uuid_cmd = dmidecode | awk -F: '/UUID/ {print $2}'
        cpu_vendor_id_chk_cmd = "cat /proc/cpuinfo | grep 'vendor_id'"
        # Parameter for checking virtio driver's signature in windows guest,
        # useless for linux guest.
        vio_driver_chk_cmd = ""
        mem_chk_re_str = ([0-9]+)
        cpu_cores_chk_cmd = "lscpu | grep '^Core'"
        cpu_sockets_chk_cmd = "lscpu | grep -E '(^Socket|^CPU socket)'"
        cpu_threads_chk_cmd = "lscpu | grep '^Thread'"
        chk_timeout = 240
    - qemu_cpu:
        virt_test_type = qemu
        virt_test_type = qemu
        type = cpuid
        start_vm = "no"
        smp = 1
    
        # ask autotest to not mess with the cpu_model settings
        auto_cpu_model = no
    
        # QEMU versions:
        variants:
            - unknown_qemu:
            - rhel64:
            - qemu13:
    
        # uncomment the line corresponding to the QEMU version, if you know it:
        only unknown_qemu
        #only rhel64
        #only qemu13
    
        # CPU model lists:
        variants:
            - cpu.unset:
                # this variant will not force cpu_model to any value
            - cpu.intel:
                variants:
                    - 486:
                        cpu_model = "486"
                    - core2duo:
                        cpu_model = "core2duo"
                    - kvm32:
                        cpu_model = "kvm32"
                    - kvm64:
                        cpu_model = "kvm64"
                    - qemu32:
                        cpu_model = "qemu32"
                    - coreduo:
                        cpu_model = "coreduo"
                    - pentium:
                        cpu_model = "pentium"
                    - pentium2:
                        cpu_model = "pentium2"
                    - pentium3:
                        cpu_model = "pentium3"
                    - n270:
                        cpu_model = "n270"
                    - Conroe:
                        cpu_model = "Conroe"
                    - Penryn:
                        cpu_model = "Penryn"
                    - Nehalem:
                        cpu_model = "Nehalem"
                    - Westmere:
                        cpu_model = "Westmere"
                    - SandyBridge:
                        cpu_model = "SandyBridge"
                    - Haswell:
                        cpu_model = "Haswell"
            - cpu.amd:
                variants:
                    - qemu64:
                        cpu_model = "qemu64"
                    - phenom:
                        cpu_model = "phenom"
                    - athlon:
                        cpu_model = "athlon"
                    - Opteron_G1:
                        cpu_model = "Opteron_G1"
                    - Opteron_G2:
                        cpu_model = "Opteron_G2"
                    - Opteron_G3:
                        cpu_model = "Opteron_G3"
                    - Opteron_G4:
                        cpu_model = "Opteron_G4"
                    - Opteron_G5:
                        cpu_model = "Opteron_G5"
                    - cpu64_rhel6:
                        only rhel64
                        cpu_model = "cpu64-rhel6"
                    - cpu64_rhel4:
                        only rhel64
                        cpu_model = "cpu64-rhel5"
    
        variants:
            - kvm:
            - nokvm:
                enable_kvm = "no"
                disable_kvm = "yes"
    
        variants:
            - check_models:
                test_type = "test_qemu_cpu_models_list"
                no cpu.unset
                # no need to check this with both kvm enabled and disabled:
                only nokvm
                # we don't know if all models will be available if QEMU
                # version is unknown:
                no unknown_qemu
            # CPUID data tests:
            - cpuid:
                # 486 is excluded due to not supporting cpuid
                no 486
                variants:
                    - default.vendor:
                        test_type = "default_vendor"
                        kvm:
                            # when KVM is enabled, all CPU models have vendor set
                            # to match host, by default
                            vendor = "host"
                            # instead of running one test case per CPU model,
                            # run only one test that checks every single model,
                            # even the ones not listed in the "cpu.*" variants above
                            only cpu.unset
                            cpu_models = "*"
                        nokvm:
                            # we don't know if all models will be available if QEMU
                            # version is unknown:
                            no unknown_qemu
                            only cpu.intel cpu.amd
                            cpu.intel:
                                    vendor = "GenuineIntel"
                            cpu.amd:
                                    vendor = "AuthenticAMD"
                    - custom:
                        # the checks below will be run without setting the CPU model
                        # explicitly. they can be repeated for each known CPU model
                        # if removing the following line:
                        only cpu.unset
                        variants:
                            - vendor:
                                test_type = "custom_vendor"
                                variants:
                                    - normal:
                                        vendor = "QWERasdfZXCV"
                                    - tooshort:
                                        vendor = "Q"
                                        xfail = "yes"
                                    - empty:
                                        xfail = "yes"
                                        vendor = ""
                            - level:
                                test_type = "custom_level"
                                variants:
                                    - level5:
                                        level = 5
                                    - NaN:
                                        xfail = "yes"
                                        level = "five"
                            - family:
                                test_type = "custom_family"
                                variants:
                                    - family6:
                                        family = 6
                                    - ext:
                                        family = 21
                                    - max:
                                        # 0xff + 0xf = 270
                                        family = 270
                                    - NaN:
                                        xfail = "yes"
                                        family = foo
                                    - out_of_range:
                                        xfail = "yes"
                                        family = 271
                            - model:
                                test_type = "custom_model"
                                variants:
                                    - model15:
                                        model = 15
                                    - max:
                                        model = 255
                                    - out_of_range:
                                        xfail = "yes"
                                        model = 256
                                    - NaN:
                                        xfail = "yes"
                                        model = foo
                            - stepping:
                                test_type = "custom_stepping"
                                variants:
                                    - stepping5:
                                        stepping = 5
                                    - max:
                                        stepping = 15
                                    - out_of_range:
                                        xfail = "yes"
                                        stepping = 16
                                    - Nan:
                                        xfail = "yes"
                                        stepping = foo
                            - xlevel:
                                test_type = "custom_xlevel"
                                variants:
                                    - fixup:
                                        # fix me when fixup in QEMU is removed
                                        xlevel = 5
                                        # expect fixup to 0x80000005
                                        expect_xlevel = 2147483653
                                    - level80000001:
                                        # xlevel = 0x80000001
                                        xlevel = 2147483649
                                    - supported_max:
                                        # xlevel = 0x8000000A
                                        xlevel = 2147483658
                                    - Nan:
                                        xfail = "yes"
                                        xlevel = foo
                            - model_id:
                                test_type = "custom_model_id"
                                model_id = "QEMU CPU Brand by virt-test"
    - qemu_guest_agent: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only Fedora.16, Fedora.17
        type = qemu_guest_agent
        gagent_name = "org.qemu.guest_agent.0"
        gagent_install_cmd = "rpm -q qemu-guest-agent || yum install -y qemu-guest-agent"
        variants:
            - gagent_install:
                gagent_check_type = install
            - check_sync:
                gagent_check_type = sync
            - check_powerdown:
                gagent_check_type = powerdown
            - check_reboot:
                only Linux
                gagent_check_type = reboot
            - check_halt:
                gagent_check_type = halt
            - check_fsfreeze:
                gagent_check_type = fsfreeze
                gagent_fs_test_cmd = "rm -f /tmp/foo; echo foo > /tmp/foo"
            - check_snapshot:
                type = qemu_guest_agent_snapshot
                gagent_check_type = fsfreeze
                gagent_fs_test_cmd = "rm -f /tmp/foo; echo foo > /tmp/foo"
                gagent_fs_check_cmd = "grep foo /tmp/foo"
        variants:
            - virtio_serial:
                gagent_serial_type = virtio
                virtio_ports += " org.qemu.guest_agent.0"
                virtio_port_type_org.qemu.guest_agent.0 = "serialport"
                gagent_start_cmd = "service qemu-guest-agent start"
            - isa_serial:
                gagent_serial_type = isa
                isa_serials += " org.qemu.guest_agent.0"
                gagent_start_cmd = "pgrep qemu-ga || qemu-ga -d -m isa-serial -p /dev/ttyS1"
    - qemu_img:
        virt_test_type = qemu
        type = qemu_img
        vms = ''
        profilers = ''
        take_regular_screendumps = no
        variants:
            - check:
                subcommand = check
                image_name_dd = dd_created_image
                force_create_image_dd = no
                remove_image_dd = yes
                create_image_cmd = "dd if=/dev/zero of=%s bs=1G count=1"
                # Test the conversion from 'dd_image_name' to specified format
                supported_image_formats = qcow2 raw qed
            - create:
                subcommand = create
                images += " large"
                force_create_image_large = yes
                image_size_large = 1G
                image_name_large = create_large_image
                remove_image_large = yes
            - convert:
                subcommand = convert
                variants:
                    - to_qcow2:
                        dest_image_format = qcow2
                        compressed = no
                        encrypted = no
                    - to_raw:
                        dest_image_format = raw
                    - to_qed:
                        dest_image_format = qed
    
            - snapshot:
                subcommand = snapshot
            - info:
                subcommand = info
            - rebase:
                subcommand = rebase
                rebase_mode = unsafe
                image_name_snapshot1 = sn1
                image_name_snapshot2 = sn2
            # Commit is the only subtest that does need an installed guest
            - commit:  install setup image_copy unattended_install.cdrom
                subcommand = commit
    - qemu_io_blkdebug:
        virt_test_type = qemu
        only qcow2
        type = qemu_io_blkdebug
        vms = ""
        images = "blk"
        image_name_blk = "blkdebug"
        image_size_blk = 1G
        image_format_blk = qcow2
        remove_image_blk = yes
        image_cluster_size = 512
        err_command = "write -b 0 1G"
        err_event = "refblock_update_part"
        errn_list = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28"
        re_std_msg = "error\s+code\s+\d+:\s+([a-zA-Z\/\-\s]+)$"
        test_timeout = 720
        blkdebug_default = blkdebug/qemu_io_default.conf
    - qemu_iotests:
        virt_test_type = qemu
        type = qemu_iotests
        vms = ''
        profilers = ''
        take_regular_screendumps = no
        qemu_io_uri = git://git.kernel.org/pub/scm/linux/kernel/git/hch/qemu-iotests.git
        qemu_io_branch = master
        qemu_io_lbranch = master
        #qemu_io_commit =
        #qemu_io_base_uri =
        #qemu_io_extra_options =
        variants:
            - raw_format:
                qemu_io_image_format = raw
            - qcow_format:
                qemu_io_image_format = qcow
            - qcow2_format:
                qemu_io_image_format = qcow2
            - qed_format:
                qemu_io_image_format = qed
            - vdi_format:
                qemu_io_image_format = vdi
            - vpc_format:
                qemu_io_image_format = vpc
            - vmdk_format:
                qemu_io_image_format = vmdk
    - qmp_basic: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = qmp_basic
        monitors = qmp1
        monitor_type = qmp
        vcpu_thread_pattern = "u'thread_id':\s+(\d+)"
    - qmp_basic_rhel6: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = qmp_basic_rhel6
        monitors = qmp1
        monitor_type = qmp
        vcpu_thread_pattern = "u'thread_id':\s+(\d+)"
    - rv_connect:
        virt_test_type = qemu
        no JeOS
        type = rv_connect
        vms = vm1 vm2
        guest_vm = vm1
        client_vm = vm2
        image_name_vm2 = client_vm
        display_vm2 = vnc
        vga_vm2 = cirrus
        full_screen = no
        virtio_ports_vm1 = "vdagent"
        virtio_port_type_vm1 = "serialport"
        virtio_port_chardev_vm1 = "spicevmc"
        virtio_port_name_prefix_vm1 = "com.redhat.spice."
    
        variants:
            - RHEL:
                variants:
                    # This is current solution of handling
                    # multiple guests running exact same OS
                    -6.3.x86_64:
                        image_name_vm2 = images/rhel6devel-64_client
                    -6.3.i386:
                        image_name_vm2 = images/rhel6devel-32_client
    - rv_connect_win:
        virt_test_type = qemu
        no JeOS
        type = rv_connect
        vms = vm1 vm2
        guest_vm = vm1
        client_vm = vm2
        image_name_vm2 = client_vm
        display_vm2 = vnc
        os_type_vm2 = linux
        shell_prompt_vm2 = ^\[.*\][\#\$]\s*$
        shell_client_vm2 = ssh
        username_vm2 = root
        shell_port_vm2 = 22
        status_test_command_vm2 = echo $?
        virtio_ports_vm1 = "vdagent"
        virtio_port_type_vm1 = "serialport"
        virtio_port_chardev_vm1 = "spicevmc"
        virtio_port_name_prefix_vm1 = "com.redhat.spice."
    
        variants:
            - RHEL:
                variants:
                    # This is current solution of handling
                    # multiple guests running exact same OS
                    -6.3.x86_64:
                        image_name_vm2 = images/rhel6devel-64_client
                    -6.3.i386:
                        image_name_vm2 = images/rhel6devel-32_client
    - rv_copyandpaste: rv_connect
        virt_test_type = qemu
        no JeOS
        type = rv_copyandpaste
        vms = vm1 vm2
        shell_prompt_vm2 = ^\[.*\][\#\$]\s*$
        guest_vm = vm1
        client_vm = vm2
        image_name_vm2 = client_vm
        display_vm2 = vnc
        vga_vm2 = cirrus
        interpreter = python
        dst_dir = /tmp
        guest_script = cb.py
        script_params_img_set = --set_image
        script_params_img_save = -m
        script_params_writef = -f
        script_params_createf = -n
        final_textfile = StringLengthTest.txt
        final_image = PNGTest.png
        image_tocopy_name = Image-small.png
        final_image_bmp = BMPTest.bmp
        image_tocopy_name_bmp = Image2.bmp
        image_type = png
        script_params = --set
        script_params_clear = --clear
        text_to_test = Testing_this_text_was_copied
        virtio_ports_vm1 = "vdagent"
        virtio_port_type_vm1 = "serialport"
        virtio_port_chardev_vm1 = "spicevmc"
        virtio_port_name_prefix_vm1 = "com.redhat.spice."
    
        variants:
            - RHEL:
                variants:
                    # This is current solution of handling
                    # multiple guests running exact same OS
                    -6.3.x86_64:
                        image_name_vm2 = images/rhel6devel-64_client
                    -6.3.i386:
                        image_name_vm2 = images/rhel6devel-32_client
    - rv_disconnect: rv_connect
        virt_test_type = qemu
        no JeOS
        type = rv_disconnect
        vms = vm1 vm2
        guest_vm = vm1
        client_vm = vm2
        image_name_vm2 = client_vm
        display_vm2 = vnc
        vga_vm2 = cirrus
        virtio_ports_vm1 = "vdagent"
        virtio_port_type_vm1 = "serialport"
        virtio_port_chardev_vm1 = "spicevmc"
        virtio_port_name_prefix_vm1 = "com.redhat.spice."
    
        variants:
            - RHEL:
                variants:
                    # This is current solution of handling
                    # multiple guests running exact same OS
                    -6.3.x86_64:
                        image_name_vm2 = images/rhel6devel-64_client
                    -6.3.i386:
                        image_name_vm2 = images/rhel6devel-32_client
    - rv_fullscreen: rv_connect
        virt_test_type = qemu
        no JeOS
        type = rv_fullscreen
        vms = vm1 vm2
        guest_vm = vm1
        client_vm = vm2
        image_name_vm2 = client_vm
        display_vm2 = vnc
        vga_vm2 = cirrus
        virtio_ports_vm1 = "vdagent"
        virtio_port_type_vm1 = "serialport"
        virtio_port_chardev_vm1 = "spicevmc"
        virtio_port_name_prefix_vm1 = "com.redhat.spice."
    
    
        variants:
            - RHEL:
                variants:
                    # This is current solution of handling
                    # multiple guests running exact same OS
                    -6.3.x86_64:
                        image_name_vm2 = images/rhel6devel-64_client
                    -6.3.i386:
                        image_name_vm2 = images/rhel6devel-32_client
    - rv_input: rv_connect
        virt_test_type = qemu
        type = rv_input
        vms = vm1 vm2
        guest_vm = vm1
        client_vm = vm2
        image_name_vm2 = client_vm
        display_vm2 = vnc
        vga_vm2 = cirrus
        full_screen = "False"
        guest_script = key_event_form.py
        virtio_ports_vm1 = "vdagent"
        virtio_port_type_vm1 = "serialport"
        virtio_port_chardev_vm1 = "spicevmc"
        virtio_port_name_prefix_vm1 = "com.redhat.spice."
    
        variants:
            - RHEL:
                variants:
                    # This is current solution of handling
                    # multiple guests running exact same OS
                    -6.3.x86_64:
                        image_name_vm2 = images/rhel6devel-64_client
                    -6.3.i386:
                        image_name_vm2 = images/rhel6devel-32_client
    - rv_logging: rv_connect
        virt_test_type = qemu
        type = rv_logging
        logtest = qxl
        qxl_log = /var/log/Xorg.0.log
        spice_log = /var/log/spice-vdagent.log
        vms = vm1 vm2
        guest_vm = vm1
        client_vm = vm2
        image_name_vm2 = client_vm
        display_vm2 = vnc
        vga_vm2 = cirrus
        interpreter = python
        dst_dir = /tmp
        guest_script = cb.py
        script_params = --set
        text_to_test = Testing_this_text_was_copied
        virtio_ports_vm1 = "vdagent"
        virtio_port_type_vm1 = "serialport"
        virtio_port_chardev_vm1 = "spicevmc"
        virtio_port_name_prefix_vm1 = "com.redhat.spice."
    
        variants:
            - RHEL:
                variants:
                    # This is current solution of handling
                    # multiple guests running exact same OS
                    -6.3.x86_64:
                        image_name_vm2 = images/rhel6devel-64_client
                    -6.3.i386:
                        image_name_vm2 = images/rhel6devel-32_client
    
    
    - seabios: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = seabios
        start_vm = no
        restart_vm = no
        kill_vm = yes
        boot_menu = on
        enable_sga = yes
        boot_menu_key = "f12"
        boot_menu_hint = "Press F12 for boot menu"
        # Specify the boot device name which you want to test here.
        boot_device = "iPXE"
    - set_link: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        requires_root = yes
        type = set_link
        test_timeout = 1000
        filesize = 4000
        transfer_timeout = 1000
        transfer_type = remote
        kill_vm =yes
    - smbios_table: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only Linux
        type = smbios_table
        requires_root = yes
        start_vm = no
    - softlockup: install setup unattended_install.cdrom
        virt_test_type = qemu
        no JeOS
        only Linux
        type = softlockup
        softlockup_files = stress-1.0.4.tar.gz
        stress_setup_cmd = "cd %s && tar xvf stress-1.0.4.tar.gz && cd stress-1.0.4 && ./configure && make && cd src"
        server_setup_cmd = "%s/heartbeat_slu.py --server --threshold %s --file %s --port %s --verbose --check-drift"
        client_setup_cmd = "%s/heartbeat_slu.py --client --address %s --file %s --port %s --interval 1"
        stress_cmd  = "cd %s && cd stress-1.0.4 && cd src && nohup ./stress -c %s > /dev/null 2>&1&"
        kill_monitor_cmd = "ps aux | grep heart | grep -v grep | awk '{print$2}' | xargs kill -9 > /dev/null 2>&1"
        kill_stress_cmd = "pkill -f stress > /dev/null 2>&1"
        drift_cmd = "tail -1 %s | awk '{print $7}'"
        monitor_log_file_server = /tmp/heartbeat_server.log
        monitor_log_file_client = /tmp/heartbeat_client.log
        monitor_port = 13330
        stress_threshold = 10
        # time_to_run (hours) = 12, 18, 24, 48 hours
        test_length = 0.10
    - sr-iov:
        virt_test_type = qemu
        only vf_assignable
        variants:
            - vf_boot:
                type = boot
                pci_assignable_nic1 = vf
            - multi_vf_boot:
                type = boot
                nics = "nic1 nic2 nic3"
                pci_assignable = vf
            - max_vf_boot:
                type = boot
                nics = "nic1 nic2 nic3 nic4 nic5 nic6 nic7"
                pci_assignable = vf
            - pf_vf_boot:
                type = boot
                nics = "nic1 nic2"
                pci_assignable_nic1 = pf
                # Need udpate device_name for pf according to your host
                device_name_nic1 = eth1
                pci_assignable_nic2 = vf
            - vf_boot_vms:
                type = boot
                vms = 'vm1 vm2'
                nics = 'nic1 nic2'
                pci_assignable = vf
                image_snapshot = yes
            - vf_hotplug:
                type = sr_iov_hotplug
                pci_assignable = vf
                reference_cmd = lspci
                find_pci_cmd = 'lspci | tail -n1'
                pci_test_cmd = 'echo %s; nslookup www.redhat.com'
                pci_num = 2
                repeat_times = 2
                wait_secs_for_hook_up = 3
            - vf_hot_unplug:
                type = sr_iov_hotunplug
                pci_assignable = vf
                reference_cmd = lspci
                nics = "nic1 nic2 nic3"
                unplug_pci_num = 2
            - vf_hotplug_500:
                type = sr_iov_hotplug
                pci_assignable = vf
                reference_cmd = lspci
                find_pci_cmd = 'lspci | tail -n1'
                pci_test_cmd = 'echo %s; nslookup www.redhat.com'
                wait_secs_for_hook_up = 3
                pci_num = 2
                repeat_times = 500
                test_timeout = 10000
            - sr_iov_negative:
                host_setup_flag = 3
                variants:
                    - vf_iommu_off:
                        start_vm = no
                        negative_msg = "\'pci-assign\' could not be initialized"
                        pci-assign_params = iommu
                        iommu = 0
                        type = sr_iov_boot_negative
                    - no-kvm:
                        pci_assignable = vf
                        disable_kvm = yes
                        enable_kvm = no
                        start_vm = no
                        type = sr_iov_boot_negative
                        negative_msg = "requires KVM support"
                    - hotplug_invaild_addr:
                        pci_assignable = vf
                        type = sr_iov_hotplug_negative
                        modprobe_cmd = modprobe -r igb
                        pci_addr = abc
                        negative_msg = "Property 'pci-assign.addr' doesn't take value 'abc'"
                    - hotplug_iommu_off:
                        pci_assignable = vf
                        type = sr_iov_hotplug_negative
                        negative_msg = "Device 'pci-assign' could not be initialized"
                        hotplug_params = iommu
                        iommu = 0
                    - more_than_max_vfs:
                        driver_option = "max_vfs=8"
                        type = boot
                        pci_assignable = vf
                        nics = "nic1 nic2 nic3 nic4 nic5 nic6 nic7 nic8"
                        pci_assignable_nic1 = pf
                        device_name_nic1 = eth1
                    - negative_max_vfs:
                        driver_option = "max_vfs=-1"
                        type = sr_iov_boot_negative
                        start_vm = no
    - sr_iov_file_transfer:
        virt_test_type = qemu
        only vf_assignable 
        type = multi_vms_file_transfer
        filesize = 4000
        transfer_timeout = 1000
        vms += " vm2"
        image_snapshot = yes
        tmp_dir = /tmp/
        repeat_time = 10
        variants:
            - vf:
                pci_assignable = vf
            - pf:
                pci_assignable_nic1 = pf
                device_name = eth1
            - vf_pf_mixed:
                pci_assignable_nic1_vm1 = pf
                device_name_vm1 = eth1
                pci_assignable_vm2 = vf
    - install:
        virt_test_type = qemu
        no JeOS
        type = steps
        fail_if_stuck_for = 300
        stuck_detection_history = 2
        keep_screendump_history = yes
        force_create_image = yes
        kill_vm = yes
        kill_vm_timeout = 60
        kill_vm_timeout_on_error = 0
    
    - setup: install
        virt_test_type = qemu
        no JeOS
        type = steps
        fail_if_stuck_for = 300
        stuck_detection_history = 2
        kill_vm_on_error = yes
        keep_screendump_history = yes
    - system_powerdown: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = shutdown
        shutdown_method = system_powerdown
        sleep_before_powerdown = 20
        kill_vm = yes
    - system_reset: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = boot
        reboot_method = system_reset
        sleep_before_reset = 20
        kill_vm_on_error = yes
    - system_reset_bootable: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = system_reset_bootable
        interval = 1
        reset_times = 20
        wait_time_for_reset = 120
        kill_vm_on_error = yes
    - time_manage:
        virt_test_type = qemu
        type = time_manage
        kill_vm = yes
        extra_params +=" -rtc base=utc,driftfix=slew -snapshot"
        # The stress command *must* be installed in the host.
        # The aim is generate huge load on host so cpu, io, vm
        # parameters values can be changed based on host configuration.
        host_load_command = stress --cpu 4 --io 4 --vm 4 --vm-bytes 1G --vm-keep
        host_load_kill_command = killall stress
        reboot_method = shell
        alive_test_cmd = uname -a
        # Set the max_itrs(iterations) and max_vms
        max_itrs = 15
        max_vms = 4
    - unit_test_kvmctl:
        virt_test_type = qemu
        no JeOS
        type = unittest_kvmctl
        vms = ''
        profilers = ''
        variants:
            - access:
                case = access
            - apic:
                case = apic
            - emulator:
                case = emulator
            - hypercall:
                case = hypercall
            - msr:
                case = msr
            - port80:
                case = port80
            - realmode:
                case = realmode
            - sieve:
                case = sieve
            - smptest:
                case = smptest
            - tsc:
                case = tsc
            - stringio:
                case = stringio
            - vmexit:
                case = vmexit
    - usb:
        virt_test_type = qemu
        virt_test_type = qemu
        only Linux
        restart_vm = yes
        kill_vm_on_error = yes
        usbs += " usbtest"
    
        # usb controllers
        variants:
            - uhci:
                usb_type_usbtest = piix3-usb-uhci
                usb_controller_testdev = uhci
                usb_max_port_usbtest = 2
                drive_format_stg = "usb1"
            - ehci:
                usb_type_usbtest = ich9-usb-ehci1
                usb_controller_testdev = ehci
                usb_max_port_usbtest = 6
                drive_format_stg = "usb2"
            - xhci:
                usb_type_usbtest = nec-usb-xhci
                usb_controller_testdev = xhci
                usb_max_port_usbtest = 4
                drive_format_stg = "usb3"
    
        # usb devices (boot+reboot tests)
        variants:
            - @usb_nodev:
                only usb_storage, usb_host
            - usb_kbd:
                only usb_boot, usb_reboot, usb_hotplug
                usb_type_testdev = "usb-kbd"
                info_usb_name = "QEMU USB Keyboard"
                vendor_id = "0627"
                product_id = "0001"
                vendor = "Adomax Technology Co., Ltd"
                product = "QEMU USB Keyboard"
            - usb_mouse:
                only usb_boot, usb_reboot, usb_hotplug
                usb_type_testdev = "usb-mouse"
                info_usb_name = "QEMU USB Mouse"
                vendor_id = "0627"
                product_id = "0001"
                vendor = "Adomax Technology Co., Ltd"
                product = "QEMU USB Mouse"
            - usb_tablet:
                only usb_boot, usb_reboot, usb_hotplug
                usb_type_testdev = "usb-tablet"
                info_usb_name = "QEMU USB Tablet"
                vendor_id = "0627"
                product_id = "0001"
                vendor = "Adomax Technology Co., Ltd"
                product = "QEMU USB Tablet"
            - usb_ccid:
                only usb_boot, usb_reboot, usb_hotplug
                usb_type_testdev = "usb-ccid"
                info_usb_name = "QEMU USB CCID"
                vendor_id = "08e6"
                product_id = "4433"
                vendor = "Gemplus"
                product = "QEMU USB CCID"
            - usb_audio:
                only usb_boot, usb_reboot, usb_hotplug
                usb_type_testdev = usb-audio
                info_usb_name = "QEMU USB Audio"
                vendor_id = "46f4"
                product_id = "0002"
                vendor = ""
                product = "QEMU USB Audio"
            - usb_hub:
                only usb_boot, usb_reboot, usb_hotplug
                usb_type_testdev = usb-hub
                info_usb_name = "QEMU USB Hub"
                vendor_id = "(0000|0409)"
                product_id = "(0000|55aa)"
                vendor = ""
                product = "QEMU USB Hub"
    
        # usb tests
        variants:
            - usb_boot:
                type = boot
                usb_devices += " testdev"
                check_func = "check_usb_device"
            - usb_reboot:
                type = boot
                reboot_method = shell
                usb_devices += " testdev"
                check_func = "check_usb_device"
            - usb_hotplug:
                type = usb_hotplug
            - usb_storage:
                type = usb
                images += " stg"
                image_boot_image1 = yes
                image_name_stg = "usbdevice"
                image_format_stg = "qcow2"
                image_boot_stg = no
                drive_index_stg = 1
                create_image_stg = yes
                image_size_stg = 10M
                fdisk_string = "10 MB, 10485760 bytes"
                format_timeout = 400
                check_serial_option = yes
                check_removable_option = yes
                check_io_size_option = yes
            - usb_host:
                # must configure which device should be used
                #usb_host_device = "<vendorid>:<productid>"
                type = usb_host
    - usb_multi_disk: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = multi_disk
        cmd_timeout = 1000
        black_list = C: D:
        start_vm = no
        kill_vm = yes
        create_image = yes
        image_boot_image1 = yes
        usbs = usb1
        usb_type = usb-ehci
        usb_max_port_usb1 = 6
        usb_max_port = 6
        usb_devices = ""
        variants:
            - signal_repeat:
                images += " stg"
                image_format_stg = qcow2
                image_name_stg = storage
                image_size_stg = 1G
                drive_format_stg = usb2
                drive_index_stg = 1
                image_boot_stg = no
                force_create_image_stg = yes
                remove_image_stg = yes
                n_repeat = 10
            - max_disk:
                start_vm = no
                usbs += " usb2 usb3 usb4"
                stg_image_num = 24
                stg_image_size = 1G
                stg_image_boot = no
                stg_drive_format = usb2
                stg_assign_index = yes
                remove_image = yes
                remove_image_image1 = no
                cmd_timeout = 1000
    - usb_storage: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only Linux
        type = usb
        kill_vm = yes
        format_timeout = 400
        usbs = usb1
        usb_devices = ""
        images += " stg"
        image_boot_image1 = yes
        image_name_stg = "usbdevice"
        image_format_stg = "qcow2"
        image_boot_stg = no
        drive_index_stg = 1
        create_image_stg = yes
        image_size_stg = 10M
        fdisk_string = "10 MB, 10485760 bytes"
        variants:
            - uhci:
                usb_type_usb1 = piix3-usb-uhci
                usb_max_port_usb1 = 2
                drive_format_stg = "usb1"
            - ehci:
                usb_type_usb1 = ich9-usb-ehci1
                usb_max_port_usb1 = 6
                drive_format_stg = "usb2"
                variants:
                    - @default:
                    - check_options:
                        check_serial_option = yes
                        check_removable_option = yes
                        check_io_size_option = yes
            - xhci:
                usb_type_usb1 = nec-usb-xhci
                usb_max_port_usb1 = 4
                drive_format_stg = "usb3"
    
    - virtio_console: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only Linux
        type = virtio_console
        # Console cleanup is not 100%, consider using kill_vm_on_error
        kill_vm_on_error = yes
        # Default number of consoles
        virtio_ports = "vc1 vc2 vc3 vc4 vs1 vs2 vs3 vs4"
        virtio_port_type = "serialport"
        virtio_port_type_vc1 = "console"
        virtio_port_type_vc2 = "console"
        virtio_port_type_vc3 = "console"
        virtio_port_type_vc4 = "console"
        virtio_console_test_time = 60
        variants:
            # Dummy and debug scripts.
            # You have to remove "no virtio_console" to be able to run those tests
            - dummy:
                # Remove this to run dummy tests
                no virtio_console
                variants:
                    # Dummy test which removes guest_script
                    - delete_guest_script:
                        virtio_console_test = delete_guest_script
    
            # Tests which can run or serialport or console
            # NOTE: By default VM have booth serialports and consoles. The difference is that it uses serialport or console as tested object. If you want to test pure VM without the other virtio_port devices change virtio_ports (or virtio_port_type) in 'virtserialport' resp 'virtconsole' variants.
            - @specifiable:
                variants:
                    # Tests which uses preprocessed VM
                    - @with_vm:
                        variants:
                            # Smoke tests
                            - open:
                               virtio_console_test = open
                            - check_zero_sym:
                                only Linux
                                virtio_console_test = check_zero_sym
                            - multi_open:
                                virtio_console_test = multi_open
                            - close:
                                virtio_console_test = close
                            - polling:
                                only Linux
                                virtio_console_test = polling
                            - sigio:
                                only Linux
                                virtio_console_test = sigio
                            - lseek:
                                only Linux
                                virtio_console_test = lseek
                            - rw_host_offline:
                                # console is always connected to underneath virtserialport.
                                only virtserialport
                                virtio_console_test = rw_host_offline
                            - rw_host_offline_big_data:
                                only Linux
                                # console is always connected to underneath virtserialport.
                                only virtserialport
                                virtio_console_test = rw_host_offline_big_data
                            - rw_blocking_mode:
                                only Linux
                                virtio_console_test = rw_blocking_mode
                            - rw_nonblocking_mode:
                                only Linux
                                # console uses blocking mode to connect to underneath virtserialport.
                                only virtserialport
                                virtio_console_test = rw_nonblocking_mode
                            - basic_loopback:
                                virtio_console_test = basic_loopback
                            # Destructive tests
                            - rmmod:
                                only Linux
                                virtio_console_test = rmmod
                            - migration:
                                virtio_console_no_migrations = 5
                                virtio_console_no_ports = 2
                                virtio_console_blocklen = 4096
                                variants:
                                    - offline:
                                        virtio_console_test = migrate_offline
                                    - online:
                                        virtio_console_test = migrate_online
                            - restart:
                                virtio_console_method = shell
                                variants:
                                    - stressed:
                                        virtio_console_test = stressed_restart
                                    - unplugged_ports:
                                        virtio_console_test = unplugged_restart
                            - interrupted_transfer:
                                only Linux
                                virtio_console_test = interrupted_transfer
                                virtio_console_buflen = 7
                                virtio_console_debug = normal
                                variants:
                                    - short:
                                        virtio_console_no_repeats = 60
                                        virtio_console_test_time = 1
                                        virtio_console_intr_time = 0.5
                                    - long:
                                        virtio_console_no_repeats = 1
                                        virtio_console_test_time = 30
                                        virtio_console_intr_time = 180
                                variants:
                                    - stop_cont:
                                        virtio_console_interruption = stop
                                    - replug_recv:
                                        only spread_linear
                                        virtio_console_interruption = replug_recv
                                    - replug_send:
                                        only spread_linear
                                        virtio_console_interruption = replug_send
                                    - replug_random:
                                        only spread_linear
                                        virtio_console_interruption = replug_random
                                    - hibernate:
                                        # set_s4_cmd and check_s4_support_cmd must
                                        # be set in guest-os.cfg
                                        virtio_console_interruption = s4
                    # Tests which creates own VMs
                    - @without_vm:
                        vms = ""
                        variants:
                            - hotplug:
                                only spread_linear
                                virtio_console_test = hotplug
                                variants:
                                    - timeout_0:
                                        virtio_console_pause = 0
                                    - timeout_1:
                                        virtio_console_pause = 1
                            # Destructive tests
                            - rw_notconnect_guest:
                                virtio_console_test = rw_notconnect_guest
                            - max_ports:
                                only spread_linear
                                virtio_port_spread = 0
                                virtio_console_test = max_ports
                # Use serialport or console as the main virtioport fpr the tests above
                variants:
                    - virtserialport:
                        # Uncomment this if you want to have VM only with serialports
                        # virtio_ports = "vs1 vs2 vs3 vs4"
                        virtio_console_params = serialport
                    - virtconsole:
                        # Uncomment this if you want to have VM only with consoles
                        # virtio_ports = "vc1 vc2 vc3 vc4"
                        virtio_console_params = console
            # Tests with different setting of the used medium
            - @unspecifiable:
                variants:
                    - loopback:
                        virtio_console_test = loopback
                        variants:
                            - virtserialport:
                                variants:
                                    - serialport_small:
                                        virtio_console_params = "serialport@4:serialport@2:serialport@4:serialport@8:8"
                                    - serialport_big:
                                        virtio_console_params = "serialport@16384:serialport@2048:serialport@4096:serialport@8192:8192"
                            - virtconsole:
                                variants:
                                    - console_small:
                                        virtio_console_params = "console@4:console@2:console@4:console@8:8"
                                    - console_big:
                                        virtio_console_params = "console@16384:console@2048:console@4096:console@8192:8192"
                            - virtmixed:
                                variants:
                                    - mixed_small:
                                        virtio_console_params = "serialport@4:console@2:serialport@5:console@6:8"
                                    - mixed_big:
                                        virtio_console_params = "console@16384:serialport@2048:console@4096:serialport@8192:8192"
                    - performance:
                        virtio_console_test = perf
                        virtio_console_params = "serialport;serialport@1000000"
                    - hotplug_virtio_pci:
                        only spread_linear
                        virtio_console_test = hotplug_virtio_pci
                        virtio_console_pause = 10
                        virtio_console_loops = 2
                    # Without VMS
                    - max_serials_and_conosles:
                        only spread_linear
                        vms = ""
                        virtio_port_spread = 0
                        virtio_console_test = max_serials_and_conosles
                    - boot_nr0:
                        start_vm = 0
                        virtio_console_test = failed_boot
                        virtio_console_params = "Port number 0 on virtio-serial devices reserved for virtconsole devices for backward compatibility."
                        virtio_ports = "vs1"
                        virtio_port_type_vs1 = serialport
                        virtio_port_params_vs1 = "nr=0"
        variants:
            # Use only single virtio-serial-pci
            - spread_linear:
                virtio_port_spread = 0
            # Spread consoles across multiple virtio-serial-pcis
            - spread_2:
                virtio_port_spread = 2
    - vmstop: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        type = vmstop
        # the path used to store the saved vm state
        # save_path = /tmp
        # clean the state file?
        clean_save = yes
    - watchdog: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only RHEL.5, RHEL.6
        type = watchdog
        extra_params += " -watchdog i6300esb -watchdog-action reset"
        relogin_timeout = 240
    - autotest: install setup image_copy unattended_install.cdrom
        no JeOS
        virt_test_type = qemu libvirt
        only Linux
        type = autotest_control
        test_timeout = 1800
        variants:
            - sleeptest:
                test_timeout = 120
                test_control_file = sleeptest.control
            - dbench:
                test_control_file = dbench.control
            - bonnie:
                test_control_file = bonnie.control
            - ebizzy:
                test_control_file = ebizzy.control
            - ffsb:
                test_control_file = ffsb.control
            - stress:
                test_control_file = stress.control
            - disktest:
                test_control_file = disktest.control
            - ctcs:
                # If you think this is too lengthy, please change the cerberus
                # control file and set this timeout appropriately.
                test_timeout = 3900
                test_control_file = ctcs.control
            - npb:
                test_control_file = npb.control
            - hackbench:
                test_control_file = hackbench.control
            - cpu_hotplug:
                test_control_file = cpu_hotplug.control
            - monotonic_time:
                test_control_file = monotonic_time.control
            - tsc:
                test_control_file = tsc.control
            - scrashme:
                test_control_file = scrashme.control
            - hwclock:
                test_control_file = hwclock.control
            - rtc:
                test_control_file = rtc.control
            - iozone:
                test_control_file = iozone.control
            - flail:
                test_control_file = flail.control
            - systemtap:
                test_control_file = systemtap.control
            - ltp:
                # This timeout has to be set inaccordance with timeout
                # argument in ltp.control (-t 1h)file.
                # Currently it is set to 1 hour and correspodingly this time
                # has been kept (3600+1000) 4600 seconds.
                # Inorder to run ltp for more time change the timeout here and
                # ltp.control file appropriately.
                test_timeout = 4600
                test_control_file = ltp.control
            - cpuflags-stress:
                test_control_file = cpuflags.control
            - scsi_testsuite:
                images += " asd"
                image_boot_image1 = yes
                image_name_asd = scsidisk
                image_format_asd = qcow2
                image_boot_asd = no
                drive_index_asd = 1
                create_image_asd = yes
                image_size_asd = 10M
                drive_serial_asd = ATST001
                pci_model = scsi
                test_control_file = scsi_testsuite.control
                variants:
                    - scsi-disk:
                        drive_format_asd = scsi-disk
            - xfstests:
                test_timeout = 4800
                test_control_file = xfstests.control
    - block_hotplug: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = pci_hotplug
        pci_type = block
        reference_cmd = lspci
        find_pci_cmd = 'lspci | tail -n1'
        images += " stg"
        boot_drive_stg = no
        image_name_stg = storage
        image_size_stg = 1G
        remove_image_stg = yes
        force_create_image_stg = yes
        pci_test_cmd = "yes | mke2fs `fdisk -l 2>&1 | awk '/\/dev\/[sv]d[a-z] doesn/ {print $2}'`"
        wait_secs_for_hook_up = 3
        kill_vm_on_error = yes
        variants:
            - block_virtio:
                pci_model = virtio
                match_string = "Virtio block device"
            - block_scsi:
                pci_model = scsi
                match_string = "LSI Logic"
        variants:
            - fmt_qcow2:
                image_format_stg = qcow2
            - fmt_raw:
                image_format_stg = raw
    - boot: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = boot
        restart_vm = yes
        kill_vm_on_error = yes
        login_timeout = 240
    - boot_savevm: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = boot_savevm
        savevm_delay = 0.3
        savevm_login_delay = 5
        savevm_timeout = 2000
        kill_vm_on_error = yes
        kill_vm_gracefully = yes
        kill_vm = yes
    - clock_getres: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        no JeOS
        only Linux
        type = clock_getres
    - dd_test: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = dd_test
        images += " stg1"
        create_image_stg1 = yes
        image_name_stg1 = stg1
        image_size_stg1 = 1M
        image_snapshot_stg1 = no
        drive_index_stg1 = 3
        dd_count = 1
        # last input and output disk
        dd_if_select = -1
        dd_of_select = -1
        variants:
            - readwrite:
                dd_stat = 0
                variants:
                    - zero2disk:
                        dd_if = ZERO
                        dd_of = /dev/[shv]d?
                    - disk2null:
                        dd_if = /dev/[shv]d?
                        dd_of = NULL
            - readonly:
                # ide, ahci don't support readonly disks
                no ide, ahci
                image_readonly_stg1 = yes
                variants:
                    - zero2disk:
                        dd_if = ZERO
                        dd_of = /dev/[shv]d?
                        dd_stat = 1
                    - disk2null:
                        dd_if = /dev/[shv]d?
                        dd_of = NULL
                        dd_stat = 0
    - ethtool: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = ethtool
        filesize = 512
    - fail_test:
        virt_test_type = libvirt kvm openvswitch v2v
        type = fail
        vms = ""
    - file_transfer: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = file_transfer
        filesize = 4000
        transfer_timeout = 1000
        variants:
            - remote:
                transfer_type = remote
    - fillup_disk: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        only qcow2
        type = fillup_disk
        fillup_timeout = 120
        fillup_size = 200
        fillup_cmd = "dd if=/dev/zero of=/%s/fillup.%d bs=%dM count=1 oflag=direct"
        kill_vm = yes
    - guest_s4: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = guest_s4
        relogin_timeout = 240
        # params: check_s4_support_cmd, check_s4_cmd, set_s4_cmd
        # kill_test_s4_cmd, services_up_timeout are set in guest-os.cfg
    - guest_test: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Windows
        type = guest_test
        login_timeout = 360
        test_timeout = 600
        script_params =
        reboot = yes
        variants:
            - autoit:
                interpreter = "cmd /c D:\AutoIt3.exe"
                variants:
                    - notepad:
                        guest_script = autoit/notepad1.au3
                        dst_rsc_path = "C:\script.au3"
                    - stub:
                        download = yes
                        download_cmd = "git clone"
                        rsc_server = "git://the.resource.server/autoit"
                        dst_rsc_dir = "C:\"
                        dst_rsc_path = "C:\autoit\stub\stub.au3"
            - powershell:
                interpreter = "cmd /c powershell.exe -File"
                variants:
                    - stub:
                        download = yes
                        download_cmd = "git clone"
                        rsc_server = "git://the.resource.server/powershell"
                        dst_rsc_dir = "C:\"
                        dst_rsc_path = "C:\powershell\stub\stub.ps1"
    - iofuzz: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = iofuzz
    
    - iometer_windows:
        only Windows
        type = iometer_windows
        images += " disk1"
        drive_index_disk1 = 2
        boot_drive_disk1 = yes
        image_name_disk1 = storage
        image_size_disk1 = 1G
        force_create_image_disk1 = yes
        writefile_cmd = echo
        kill_vm = yes
        cmd_timeout = 1200
    
        create_partition_cmd = "echo select disk 1 > imDiskpart.script && echo create partition primary >> imDiskpart.script && echo assign letter=E >> imDiskpart.script && echo exit >> imDiskpart.script && diskpart /s imDiskpart.script"
        format_cmd = format E: /FS:NTFS /V:local /Q /y
        cdrom_cd1 = isos/windows/winutils.iso
        iometer_installation_cmd = "cmd /c WIN_UTILS:\autoit3.exe WIN_UTILS:\Iometer\iometer.au3"
        iometer_reg = "cmd /c WIN_UTILS:\autoit3.exe WIN_UTILS:\Iometer\iometer-reg.au3"
        iometer_run = "cmd /c C:\Iometer\Iometer.exe /c WIN_UTILS:\Iometer\iometer.icf /r C:\autotest_iometer_result.csv"
        guest_path = "C:\autotest_iometer_result.csv"
    
        variants:
            - @default:
                iometer_timeout = 1000
                variants:
                    - aio_native:
                        image_aio = native
                    - aio_threads:
                        image_aio = threads
            - performance:
                iometer_run = "cmd /c C:\Iometer\Iometer.exe /c WIN_UTILS:\Iometer\iometer-block-2-256-queue-1-128-E.icf /r C:\autotest_iometer_result.csv"
                iometer_timeout = 23400
                variants:
                    - msi_on:
                        cpu_family = "0xf"
                    - msi_off:
                        cpu_family = "0xe"
    
    - ioquit: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = ioquit
        background_cmd = "for i in 1 2 3 4; do (dd if=/dev/urandom of=/tmp/file bs=102400 count=10000000 &); done"
        check_cmd = ps -a | grep dd
        login_timeout = 360
    - iozone_windows: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Windows
        type = iozone_windows
        iozone_cmd = "D:\IOzone\iozone.exe -a"
        iozone_timeout = 3600
    - kdump: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only RHEL.5, RHEL.6
        type = kdump
        # time waited for the completion of crash dump
        # crash_timeout = 360
        # command to add the crashkernel=X@Y to kernel cmd line
        # kernel_param_cmd = "grubby --update-kernel=`grubby --default-kernel` --args=crashkernel=128M@64M"
        # command to enable kdump service
        # kdump_enable_cmd = chkconfig kdump on && service kdump start
        # command to probe the crash kernel
        # crash_kernel_prob_cmd = "grep -q 1 /sys/kernel/kexec_crash_loaded"
        # crash_cmd = "echo c > /proc/sysrq-trigger"
        variants:
            - @default:
            - nmi:
                kernel_param_cmd = "grubby --update-kernel=`grubby --default-kernel` --args='crashkernel=128M nmi_watchdog=1'"
                crash_cmd = nmi
    - linux_s3: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = linux_s3
    - lvm: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        images += ' stg1 stg2'
        image_name_stg1 = storage_4k
        image_cluster_size_stg1 = 4096
        image_size_stg1 = 1G
        image_format_stg1 = qcow2
        image_name_stg2 = storage_64k
        image_cluster_size_stg2 = 65536
        image_size_stg2 = 1G
        image_format_stg2 = qcow2
        guest_testdir = /mnt
        disks = "/dev/sdb /dev/sdc"
        kill_vm = no
        post_command_noncritical = no
        variants:
            - lvm_create:
                type = lvm
                force_create_image_stg1 = yes
                force_create_image_stg2 = yes
                clean = no
            - lvm_fill: lvm_create
                type = fillup_disk
                force_create_image_stg1 = no
                force_create_image_stg2 = no
                guest_testdir = /mnt/kvm_test_lvm
                fillup_timeout = 120
                fillup_size = 20
                fillup_cmd = "dd if=/dev/zero of=%s/fillup.%d bs=%dM count=1 oflag=direct"
            - lvm_ioquit: lvm_create
                type = ioquit
                force_create_image_stg1 = no
                force_create_image_stg2 = no
                kill_vm = yes
                background_cmd = "for i in 1 2 3 4; do (dd if=/dev/urandom of=/mnt/kvm_test_lvm/file bs=102400 count=10000000 &); done"
                check_cmd = pgrep dd
                clean = yes
                remove_image_stg1 = yes
                remove_image_stg2 = yes
    - mac_change: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = mac_change
        kill_vm = yes
    - multicast: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = multicast
        mcast = 225.0.0.1
        mgroup_count = 20
        flood_minutes = 1
    - netperf: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        no JeOS
        only Linux
        only virtio_net
        type = netperf
        kill_vm = yes
        image_snapshot = yes
        nics += ' nic2'
        # nic1 is for control, nic2 is for data connection
        netdst_nic1 = virbr0
        nic_model_nic1 = virtio
        netdst_nic2 = switch
        nic_model_nic2 = e1000
        netperf_files = netperf-2.6.0.tar.bz2
        setup_cmd = "cd /tmp && rm -rf netperf-2.6.0 && tar xvfj netperf-2.6.0.tar.bz2 && cd netperf-2.6.0 && ./configure --enable-burst --enable-demo=yes && make"
        # configure netperf test parameters, some seconds will be took to
        # wait all the clients work, this wait time should be less than
        # 0.5 * l, the wait time will augments if you have move
        # threads. So experientially suggest l should be not less than 60.
        l = 60
        protocols = "TCP_STREAM TCP_MAERTS TCP_RR"
        sessions = "1 2 4"
        sessions_rr = "50 100 250 500"
        sizes = "64 256 512 1024"
        sizes_rr = "64 256 512 1024"
        numa_node = -1
        username_client = root
        password_client = 123456
        shell_client_client = ssh
        shell_port_client = 22
        shell_prompt_client =  \[root@.{0,50}][\#\$]
        shell_port_host = 22
        password_host = 123456
        username_host = root
        os_type_client = linux
        os_type_host = linux
        shell_prompt_host =  \[root@.{0,50}][\#\$]
        ver_cmd = rpm -qa |grep kvm
    
        # this script is used to setup test env for (linux)guest/host
        # before performance testing
        # rh_perf_envsetup_script = scripts/rh_perf_envsetup.sh
        client = vm2
        variants:
            - guest_guest:
                vms += " vm2"
                nics = 'nic1'
            - host_guest:
                client = localhost
                # to test exthost <-> guest:
                # client = <external host ip>
    
    - netperf_win:
        only Windows
        # only support guest run netserver and host run netperf now.
        host = localhost
        # this is a default value in test env
        # please change this to your client machine ip if your guest
        # uses static ip
        client = vm2
        type = netperf
        kill_vm = yes
        image_snapshot = yes
        pci_model_nic1 = virtio_net
        # Please update following comments params when you need special cfg for
        # your test nic cards
        # please fix the mac for nic2 if you needed with this, this can be empty
        # nic_mac_nic2 =
        # bridge_nic1 =
        # please add the physical nic you want to add to your private bridge
        # this can be empty
        # physical_nic =
        # bridge_force_create=yes
        pci_model_nic2 = e1000
        nics += ' nic2'
        netperf_files = netperf-2.6.0.tar.bz2
        setup_cmd = "cd /tmp && rm -rf netperf-2.6.0 && tar xvfj netperf-2.6.0.tar.bz2 && cd netperf-2.6.0 && ./configure --enable-burst --enable-demo=yes && make"
        guest_ver_cmd = "ver"
        netperf_with_numa = yes
        # configure netperf test parameters
        l = 30
        protocols = "TCP_STREAM TCP_MAERTS TCP_RR"
        sessions_rr="1 25 50 100"
        sessions="1 2 4"
        sizes_rr="256"
        sizes="256 1024 4096 16384 65535"
        numa_node = -1
        username_client = root
        password_client = 123456
        shell_client_client = ssh
        shell_port_client = 22
        shell_prompt_client =  \[root@.{0,50}][\#\$]
        shell_port_host = 22
        password_host = 123456
        username_host = root
        os_type_client = linux
        os_type_host = linux
        shell_prompt_host =  \[root@.{0,50}][\#\$]
        ver_cmd = rpm -qa |grep kvm
        variants:
            - netperf_exe:
                use_cygwin = no
                netserv_start_cmd = "(dir C:\temp || mkdir C:\temp) && start /b D:\netserver.exe"
                variants:
                    - default_setting:
                    - best_registry_setting:
                        reboot_after_config = yes
                        # For more information about windows registry setting document, please refer to http://www.linux-kvm.org/page/WindowsGuestDrivers/kvmnet/registry
                        config_cmds = afd_cmd1,afd_cmd2,afd_cmd3, tcpip_cmd1,tcpip_cmd2
                        afd_cmd1 = reg add "HKLM\SYSTEM\CurrentControlSet\Services\AFD\Parameters" /v DefaultSendWindow /d 0x00100000 /t REG_DWORD /f
                        afd_cmd2 = reg add "HKLM\SYSTEM\CurrentControlSet\Services\AFD\Parameters" /v DefaultReceiveWindow /d 0x00100000 /t REG_DWORD /f
                        afd_cmd3 = reg add "HKLM\SYSTEM\CurrentControlSet\Services\AFD\Parameters" /v FastSendDatagramThreshold /d 0x00004000 /t REG_DWORD /f
                        tcpip_cmd1 = reg add "HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters" /v Tcp1323Opts /d 0x00000001 /t REG_DWORD /f
                        tcpip_cmd2 = reg add "HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters" /v TcpWindowSize /d 0x00100000 /t REG_DWORD /f
                        disable_tcp_heuristics_cmd = "netsh int tcp set heuristics disabled"
                        disabled_tcp_autotuning_cmd = "netsh int tcp set global autotuninglevel=disabled"
                        enable_ctcp_cmd = "netsh int tcp set global congestionprovider=ctcp"
                        Win2008, Win2008r2, Win7:
                            config_cmds += ,disable_tcp_heuristics_cmd,disabled_tcp_autotuning_cmd,enable_ctcp_cmd
            - netperf_cygwin:
                use_cygwin = yes
                netperf_src = D:\netperf\netperf-2.6.0
                cygwin_root = C:\rhcygwin\home\Administrator
                cygwin_start = C:\rhcygwin\Cygwin.bat -i /Cygwin-Terminal.ico -
                netserv_pattern = "hostname\s+[\d+\.]+\s+port\s+\d+"
                netserv_start_cmd = netserver
                netperf_install_cmd = cd netperf-2.6.0; ./configure --enable-burst --enable-demo=yes; make; make install
    - netstress_kill_guest: install setup unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = netstress_kill_guest
        image_snapshot = yes
        # There should be enough vms for build topology.
        variants:
            -driver:
                mode = driver
            -load:
                mode = load
                netperf_files = netperf-2.4.5.tar.bz2 wait_before_data.patch
                packet_size = 1500
                setup_cmd = "cd %s && tar xvfj netperf-2.4.5.tar.bz2 && cd netperf-2.4.5 && patch -p0 < ../wait_before_data.patch && ./configure && make"
                clean_cmd = " while killall -9 netserver; do True test; done;"
                netserver_cmd =  %s/netperf-2.4.5/src/netserver
                netperf_cmd = %s/netperf-2.4.5/src/netperf -t %s -H %s -l 60 -- -m %s
    - nic_bonding: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu
        only Linux
        type = nic_bonding
        nics += ' nic2 nic3 nic4'
        image_snapshot = yes
        serial_login = yes
        test_timeout = 1000
        filesize = 4000
        transfer_timeout = 1000
        transfer_type = remote
        kill_vm = yes
        # you can specify the parameters of bonding module here
        # bonding_params = "mode=active-backup"
    - nic_promisc: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = nic_promisc
        filesize = 400
        transfer_timeout = 100
        transfer_type = remote
    - nicdriver_unload: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = nicdriver_unload
        filesize = 100
        transfer_timeout = 100
        transfer_type = remote
        sessions_num = 10
    - ntttcp:
        virt_test_type = qemu libvirt
        only Windows
        type = ntttcp
        image_snapshot = yes
        check_ntttcp_cmd = "cmd /c dir C:\NTttcp"
        ntttcp_sender_cmd = "cmd /c C:\NTttcp\NTttcps.exe -m %s,0,%s -a 2 -l %s -n %s"
        ntttcp_receiver_cmd = "cmd /c C:\NTttcp\NTttcpr.exe -m %s,0,%s -a 6 -rb %s -n %s"
        session_num = 1
        buffers = "2k 4k 8k 16k 32k 64k 128k 256k 512k 1024k 2048k"
        timeout = 1200
        kill_vm = yes
        numa_node = -1
        variants:
            - guest_guest:
                vms += " vm2"
            - guest_host:
                # external Windows system IP, NTttcp need to be installed firstly.
                receiver_address = "192.168.1.1"
        32:
            ntttcp_install_cmd = 'cmd /c "D:\autoit3.exe D:\NTttcp\NTttcp.au3 && mkdir C:\NTttcp && copy "C:\Program Files\Microsoft Corporation\NT Testing TCP Tool\*" C:\NTttcp && cd C:\NTttcp\ && copy NTttcp_%s.exe NTttcps.exe && copy NTttcp_%s.exe NTttcpr.exe"'
        64:
            ntttcp_install_cmd = 'cmd /c "D:\autoit3.exe D:\NTttcp\NTttcp.au3 && mkdir C:\NTttcp && copy "C:\Program Files (x86)\Microsoft Corporation\NT Testing TCP Tool\*" C:\NTttcp && cd C:\NTttcp\ && copy NTttcp_%s.exe NTttcps.exe && copy NTttcp_%s.exe NTttcpr.exe"'
    - ping: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = ping
        counts = 100
        flood_minutes = 10
        variants:
            - multi_nics:
                nics += ' nic2'
            - ext_host:
                ping_ext_host = "yes"
                ext_host_get_cmd = "ip route | awk '/default/ { print $3 }'"
    - pxe:
        virt_test_type = qemu libvirt
        type = pxe
        requires_root = yes
        images = pxe
        image_name_pxe = pxe-test
        image_size_pxe = 1G
        force_create_image_pxe = yes
        remove_image_pxe = yes
        boot_once = n
        kill_vm_on_error = yes
        network = bridge
        restart_vm = yes
        pxe_timeout = 60
        image_verify_bootable = no
    - reboot: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = boot
        reboot_method = shell
        kill_vm_on_error = yes
        login_timeout = 240
        # this script is used to setup test env for (linux)guest/host
        # before performance testing
        # rh_perf_envsetup_script = scripts/rh_perf_envsetup.sh
    - save_restore: install setup image_copy boot
        virt_test_type = qemu libvirt
        type = save_restore
        # Number of times to repeat save/restore
        save_restore_repeat = 1
        # Seconds to allow for guest runtime
        save_restore_start_delay = 4.0
        # Seconds to wait before restoring guest
        save_restore_delay = 1.0
        # Maximum time test allowed to run
        save_restore_duration = 60.0
        # Guest command to run, e.g.: Keep one CPU busy and memory dirty.
        # Note: Command will be backgrounded by appending a '&'
        save_restore_bg_command = '( mkdir -p /x && mount -t tmpfs -o size=75% x /x && while true; do dd if=/dev/urandom of=/x/x; done; umount /x && rmdir /x )'
        save_restore_path = "/tmp"
        kill_unresponsive_vms = no
        restart_vm = no
        kill_vm = yes
        variants:
            # Tests assumed to include install and boot before,
            # and a shutdown after the lifecycle test
            - lifecycle_short: unattended_install.cdrom boot
                save_restore_repeat = 25
                save_restore_duration = 1200.0
            - lifecycle_medium: unattended_install.cdrom boot
                save_restore_repeat = 50
                save_restore_delay = 1.0
                save_restore_duration = 2600.0
            - lifecycle_long: unattended_install.cdrom boot
                save_restore_repeat = 100
                save_restore_duration = 5400.0
    - skip_test:
        virt_test_type = libvirt kvm openvswitch v2v
        type = skip
        vms = ""
    - stop_continue: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = stop_continue
        kill_vm_on_error = yes
    - stress_boot: install setup image_copy unattended_install.cdrom
        virt_test_type = libvirt kvm
        type = stress_boot
        max_vms = 5
        alive_test_cmd = uname -a
        login_timeout = 240
        kill_vm = yes
        kill_vm_vm1 = no
        kill_vm_gracefully = no
        extra_params += " -snapshot"
        used_cpus = 5
        used_mem = 2560
    - timedrift: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        rtc_drift = "slew"
        variants:
            - ntp:
                no JeOS
                variants:
                    - with_load:
                        type = timedrift
                        # Pin the VM and host load to CPU #0
                        cpu_mask = 0x1
                        # Set the load and rest durations
                        load_duration = 20
                        rest_duration = 20
                        # Fail if the drift after load is higher than 50%
                        drift_threshold = 50
                        # Fail if the drift after the rest period is higher than 10%
                        drift_threshold_after_rest = 10
                        # For now, make sure this test is executed alone
                        used_cpus = 100
                    - with_migration:
                        type = timedrift_with_migration
                        migration_iterations = 3
                        drift_threshold = 10
                        drift_threshold_single = 3
                    - with_reboot:
                        type = timedrift_with_reboot
                        reboot_iterations = 1
                        drift_threshold = 10
                        drift_threshold_single = 3
                    - with_stop:
                        type = timedrift_with_stop
                        stop_interations = 1
                        drift_threshold = 10
                        drift_threshold_single = 3
            - date:
                variants:
                    - with_load:
                        type = timedrift
                        # Pin the VM and host load to CPU #0
                        cpu_mask = 0x1
                        # Set the load and rest durations
                        load_duration = 20
                        rest_duration = 20
                        # Fail if the drift after load is higher than 50%
                        drift_threshold = 50
                        # Fail if the drift after the rest period is higher than 10%
                        drift_threshold_after_rest = 10
                        # For now, make sure this test is executed alone
                        used_cpus = 100
                    - with_migration:
                        type = timedrift_with_migration
                        migration_iterations = 3
                        drift_threshold = 10
                        drift_threshold_single = 3
                    - with_reboot:
                        type = timedrift_with_reboot
                        reboot_iterations = 1
                        drift_threshold = 10
                        drift_threshold_single = 3
                    - with_stop:
                        type = timedrift_with_stop
                        stop_interations = 1
                        drift_threshold = 10
                        drift_threshold_single = 3
    - trans_hugepage: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        requires_root = yes
        thp_test_config = ""
        kill_vm = yes
        login_timeout = 360
        setup_thp = yes
        variants:
            - base:
                type = trans_hugepage
                dd_timeout = 900
            - defrag:
                type = trans_hugepage_defrag
            - swapping:
                type = trans_hugepage_swapping
                dd_timeout = 900
                check_cmd_timeout = 900
    - vlan: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = vlan
        # subnet should not be used by host
        subnet = "192.168"
        vlan_num = 5
        file_size = 10
        maximal = 4094
        listen_cmd = "nc -l %s > %s"
        send_cmd = "nc %s %s < %s"
        vms += " vm2"
        image_snapshot = yes
        kill_vm_vm2 = yes
        kill_vm_gracefully_vm2 = no
    - warning_test:
        virt_test_type = libvirt kvm openvswitch v2v
        type = warning
        vms = ""
    - whql: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Windows
        # Replace this with the address of an installed DTM server
        server_address = 10.20.30.40
        # The server should run rss.exe like a regular Windows VM, preferably
        # with administrator privileges (or at least with permission to write
        # to the DTM studio directory)
        server_shell_port = 10022
        server_file_transfer_port = 10023
        server_studio_path = %programfiles%\Microsoft Driver Test Manager\Studio
        dsso_test_binary = deps/whql_submission_15.exe
        dsso_delete_machine_binary = deps/whql_delete_machine_15.exe
        wtt_services = wttsvc
        variants:
            - support_vm_install:
                # The support VM is identical to the tested VM in every way
                # except for the image name which ends with '-supportvm'.
                type = unattended_install
                image_name += -supportvm
                boot_once = d
                force_create_image = yes
                kill_vm = yes
                redirs += " unattended_install"
                guest_port_unattended_install = 12323
                medium = cdrom
                kernel =
                initrd =
            - client_install:    support_vm_install
                type = whql_client_install
                # The username and password are required for accessing the DTM client
                # installer binary shared by the server
                server_username = administrator
                server_password = 1q2w3eP
                # This path refers to a shared directory on the server
                # (the final cmd will be something like \\servername\DTMInstall\...)
                install_cmd = \DTMInstall\Client\Setup.exe /passive
                install_timeout = 3600
                # The test will setup auto logon on the client machine using the
                # following username and password:
                client_username = DTMLLUAdminUser
                client_password = Testpassword,1
                # (These are created by the DTM client installer and should probably not
                # be changed.)
                variants:
                    - @original:
                    - support_vm:
                        image_name += -supportvm
            - submission:    client_install support_vm_install
                type = whql_submission
                extra_params += " -snapshot"
                restart_vm = yes
                cdroms =
                test_timeout = 3600
                device_data = cat0 cat1 cat2 cat3 prog desc virt filter logoarch logoos whqlos whqlqual
                descriptors = desc1 desc2 desc3
                # DeviceData names
                dd_name_cat0     = Category
                dd_name_cat1     = Category
                dd_name_cat2     = Category
                dd_name_cat3     = Category
                dd_name_logoarch = LogoProcessorArchitecture
                dd_name_logoos   = LogoOperatingSystem
                dd_name_whqlos   = WhqlOs
                dd_name_whqlqual = WhqlQualification
                dd_name_prog     = LogoProgramId
                dd_name_desc     = LogoProgramDescription
                dd_name_filter   = WDKFilterAttribute
                dd_name_virt     = ParaVirtualizationDriver
                # Common DeviceData data
                dd_data_filter   = FilterIfNoInf
                dd_data_virt     = True
                # Exclude jobs that have '(Manual)' in their names
                job_filter = ^((?!\(Manual\)).)*$
                variants:
                    - unclassified:
                        dd_data_cat0 = Device Fundamentals
                        dd_data_cat1 = System Fundamentals\Dynamic Partitioning
                        dd_data_prog = Unclassified
                        dd_data_desc = Unclassified
                        dd_data_whqlqual = Unclassified Signature
                        variants:
                            - tablet:
                                submission_name = tablet
                                extra_params += " -usbdevice tablet"
                                test_device = HID-compliant mouse
                                test_timeout = 36000
                    - device:
                        variants:
                            - keyboard:
                                submission_name = keyboard
                                # test_device is a regular expression that should match a device's
                                # name as it appears in device manager.  The first device that matches
                                # is used.
                                test_device = keyboard
                                # Set timeout to 10 hours
                                test_timeout = 36000
                                dd_data_cat0 = Input\Keyboard
                                dd_data_cat1 = Device Fundamentals
                                dd_data_cat2 = System Fundamentals\Dynamic Partitioning
                                dd_data_prog = InputKbd
                                dd_data_desc = Input > Keyboard
                            - net:
                                submission_name = net
                                # Add a support machine and extra NICs
                                vms += " supportvm"
                                nics += " nic2 nic3"
                                test_device = RTL8139.*NIC$
                                test_timeout = 86400
                                dd_data_cat0 = Network\LAN (Ethernet)
                                dd_data_cat1 = Device Fundamentals
                                dd_data_cat2 = System Fundamentals\Dynamic Partitioning
                                dd_data_prog = NetLan
                                dd_data_desc = Network > LAN (Ethernet)
                                # Machine dimensions
                                dimensions = testrole
                                dim_name_testrole = NetDevice\TestRole
                                dim_value_testrole_vm1 = NdistestLanClient
                                dim_value_testrole_supportvm = NdistestLanServer
                                # Device selection for the NDISTest client machine
                                device_params_vm1 = testdev clientmsgdev clientsupportdev
                                dp_name_testdev = NdistestLanClientTestDevice
                                dp_regex_testdev = RTL8139.*NIC$
                                dp_name_clientmsgdev = NdistestLanClientMessageDevice
                                dp_regex_clientmsgdev = RTL8139.*NIC #2$
                                dp_name_clientsupportdev = NdistestLanClientSupportDevice0
                                dp_regex_clientsupportdev = RTL8139.*NIC #3$
                                # Device selection for the NDISTest server machine
                                device_params_supportvm = servermsgdev serversupportdev
                                dp_name_servermsgdev = NdistestLanServerMessageDevice
                                dp_regex_servermsgdev = RTL8139.*NIC$
                                dp_name_serversupportdev = NdistestLanServerSupportDevice0
                                dp_regex_serversupportdev = RTL8139.*NIC #2$
                            - hdd:
                                submission_name = hdd
                                # Run the tests on a non-system drive
                                # (match device names that contain 'QEMU HARDDISK' and do not contain '[C]')
                                test_device = ^(?=.*?\bQEMU HARDDISK\b)((?!\[C\]).)*$
                                device_data += " ex0 ex1 ex2 ex3"
                                dd_data_cat0 = Storage\Device Class\Disk\Disk
                                dd_data_cat1 = Storage\Device Class\Disk\Fixed
                                dd_data_cat2 = Storage\Device Class\Disk\Bus\ATA
                                dd_data_cat3 = Device Fundamentals
                                dd_data_prog = StorHDD
                                dd_data_desc = Storage > Hard Disk Drive (HDD)
                                dd_name_ex0 = Storage_bus_type
                                dd_data_ex0 = ATA/ATAPI
                                dd_name_ex1 = Hybrid_HDD_Support
                                dd_data_ex1 = 0
                                dd_name_ex2 = Non_Rotating_Media
                                dd_data_ex2 = 0
                                dd_name_ex3 = Secure_Storage
                                dd_data_ex3 = 0
                                # Add a 2nd disk which will become D:
                                images += " tmp"
                                image_name_tmp = tmp
                                image_size_tmp = 4G
                                force_create_image_tmp = yes
                                # Run diskpart to partition the 2nd disk
                                whql_pre_command = "echo select disk=1 > dp.txt && "
                                whql_pre_command += "echo create partition primary >> dp.txt && "
                                whql_pre_command += "echo assign letter=d >> dp.txt && "
                                whql_pre_command += "diskpart /s dp.txt & "
                                whql_pre_command += "format d: /fs:ntfs /q /y"
                                variants:
                                    - full:
                                        # Yes, 100 hours, this is not a mistake
                                        test_timeout = 360000
                                    - syscache_test:
                                        job_filter = syscache test
                                        test_timeout = 7200
    - yum_update: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Fedora, RHEL
        type = yum_update
        shell_prompt = "Is this ok"
    # Drop-in test - auto generated snippet
    - unittest:
        virt_test_type = qemu
        type = unittest
    # Drop-in test - auto generated snippet
    - stepmaker:
        virt_test_type = qemu
        type = stepmaker
    # Drop-in test - auto generated snippet
    - build:
        virt_test_type = qemu
        type = build
    - shutdown: install setup image_copy unattended_install.cdrom
        virt_test_type = libvirt kvm
        type = shutdown
        shutdown_method = shell
        kill_vm = yes
        kill_vm_gracefully = no
